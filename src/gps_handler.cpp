#include "gps_handler.h"
#include "casic_gps_wrapper.h" // For CASIC protocol support
#include "config.h"
#include "gpx_logger.h"  // For appendGpxPoint
#include "logger.h"      // For Log
#include "system_info.h" // For gSystemInfo and GpsState_t
#include <Arduino.h>
#include <stdint.h> // For uint32_t, int32_t
#include <vector>   // For AGNSS message queue

// --- State Machine Constants (as per state_spec.md, kept internal to
// gps_handler.cpp) ---
static const unsigned long T_ACTIVE_SAMPLING_INTERVAL =
    10 * 1000UL; // 10 seconds
// ACCEL_STILL_THRESHOLD is used by accel_handler, gSystemInfo.isStationary
// reflects its outcome
static const unsigned long T_STILLNESS_CONFIRM_DURATION =
    60 * 1000UL;                                       // 60 seconds
static const float GPS_SPEED_VEHICLE_THRESHOLD = 5.0f; // 5 km/h
static const unsigned long T_GPS_QUERY_TIMEOUT_FOR_STILLNESS =
    5 * 1000UL; // 5 seconds
static const unsigned long T_GPS_COLD_START_FIX_TIMEOUT =
    90 * 1000UL; // 90 seconds
static const unsigned long T_GPS_REACQUIRE_FIX_TIMEOUT =
    30 * 1000UL; // 30 seconds
static const unsigned long T_GPS_SLEEP_PERIODIC_WAKE_INTERVAL =
    15 * 60 * 1000UL; // 15 minutes
// AGNSS related constants
static const unsigned long T_AGNSS_MESSAGE_SEND_TIMEOUT =
    30 * 1000UL;                                                 // 5 seconds
static const unsigned long T_AGNSS_TOTAL_TIMEOUT = 60 * 10000UL; // 60 seconds
static const uint8_t MAX_AGNSS_MESSAGE_RETRY = 30;               // 3 retries
// MIN_HDOP_FOR_VALID_FIX is in config.h

// --- GPS objects and internal state variables ---
CasicGpsWrapper gpsWrapper; // CASIC GPS wrapper that includes TinyGPS++
HardwareSerial &gpsSerial = GPS_SERIAL; // Use definition from config.h

// Structure to hold position data, similar to the old one but might not be
// strictly needed if gSystemInfo is always up-to-date before logging.
struct PositionResult {
  uint32_t timestamp{0};
  double latitude{0};
  double longitude{0};
  double altitude_m{0};
  double hdop{1e9};
};
static PositionResult last_successful_position =
    PositionResult{}; // Still useful for logging the *last good* fix

// Internal Timers for State Machine (timestamps of when the timer period
// started)
static unsigned long Stillness_Confirm_Timer_Start = 0;
static unsigned long Active_Sampling_Timer_Start = 0;
static unsigned long Fix_Attempt_Timer_Start = 0;
static unsigned long Periodic_Wake_Timer_Start = 0;
static unsigned long GPS_Query_Timeout_Timer_S4_Start = 0;
static bool isGpsPoweredOn = false;

static uint8_t Consecutive_Fix_Failures_Counter = 0;
// AGNSS related variables
static unsigned long AGNSS_Message_Timer_Start = 0;
static unsigned long AGNSS_Total_Timer_Start = 0;
static bool AGNSS_Request_Pending = true; // Flag to indicate AGNSS request
static std::vector<std::vector<uint8_t>> AGNSS_Message_Queue = {
    {0xBA, 0xCE, 0x38, 0x00, 0x0B, 0x01, 0x97, 0xFF, 0x90, 0x7E, 0xFB,
     0x3A, 0x3F, 0x40, 0x5F, 0x07, 0xCE, 0x19, 0x51, 0x5E, 0x5E, 0x40,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40, 0x00, 0xE0, 0x20,
     0xB3, 0x00, 0x8D, 0x18, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x20, 0x41, 0x00, 0x00, 0x80, 0x3F, 0x00, 0x00, 0x80, 0x3F, 0x00,
     0x00, 0x00, 0x00, 0x41, 0x09, 0x01, 0x07, 0xBB, 0x16, 0x86, 0x15},

    // 包 1: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x32, 0x32, 0xF1, 0x81, 0x06, 0xC8,
     0x0D, 0xA1, 0x51, 0xAE, 0x49, 0x00, 0xF5, 0x47, 0x39, 0x09, 0x4B, 0x48,
     0xDA, 0x75, 0x50, 0x3A, 0x15, 0x27, 0xAA, 0xF4, 0xF3, 0x46, 0x1C, 0xA7,
     0xFF, 0xFF, 0x65, 0x32, 0xA5, 0xFD, 0x10, 0xF9, 0x97, 0x0F, 0x54, 0x1D,
     0xF7, 0xF7, 0xF5, 0xFF, 0xFC, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xDA, 0x43, 0x09, 0x00, 0x63, 0x00, 0x00, 0xED, 0xA9, 0x00,
     0x01, 0x00, 0x01, 0x03, 0x00, 0x00, 0xAC, 0x64, 0xEA, 0x0A},

    // 包 2: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x51, 0x61, 0x70, 0x86, 0x7C, 0x99,
     0x0D, 0xA1, 0xE8, 0x18, 0x64, 0x08, 0xFF, 0x58, 0x21, 0xD8, 0xB3, 0xF9,
     0x8C, 0xBC, 0xB8, 0xF2, 0x54, 0x27, 0xB9, 0xB1, 0x45, 0x40, 0xFA, 0xA5,
     0xFF, 0xFF, 0x0A, 0x32, 0x88, 0xFD, 0x0D, 0xFA, 0xF4, 0x0E, 0x01, 0x1F,
     0xB5, 0xF8, 0x29, 0xFF, 0x45, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xF7, 0xFE, 0xFA, 0xFF, 0x51, 0x00, 0x00, 0xDA, 0x65, 0x00,
     0x01, 0x00, 0x02, 0x03, 0x00, 0x00, 0xEA, 0xC2, 0xE8, 0x13},

    // 包 3: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xD0, 0xB9, 0x83, 0xAD, 0x8E, 0x2C,
     0x0E, 0xA1, 0x75, 0x71, 0x39, 0x03, 0x16, 0xA1, 0xB5, 0x2F, 0x8D, 0x65,
     0x17, 0x29, 0x7F, 0xCD, 0x56, 0x28, 0x5E, 0xDE, 0xD3, 0x6E, 0x72, 0xAB,
     0xFF, 0xFF, 0x4E, 0x29, 0xD5, 0x01, 0x84, 0xFE, 0xAD, 0x14, 0xCA, 0x19,
     0x48, 0xFE, 0xD1, 0xFF, 0x20, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x20, 0xB4, 0x16, 0x00, 0x04, 0x00, 0x00, 0x03, 0x67, 0x00,
     0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0xE8, 0x73, 0x0F, 0x62},

    // 包 4: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xE1, 0xBE, 0x2C, 0x92, 0x8F, 0xE0,
     0x0C, 0xA1, 0x4C, 0x72, 0xAD, 0x01, 0xAB, 0x08, 0x79, 0x89, 0xC0, 0x06,
     0x40, 0xA0, 0xDA, 0x35, 0x70, 0x27, 0x16, 0x88, 0x95, 0x9A, 0x21, 0xA8,
     0xFF, 0xFF, 0xA1, 0x31, 0x1D, 0x01, 0xF8, 0xFE, 0x4A, 0x0C, 0xC6, 0x21,
     0xEE, 0xFE, 0xF3, 0xFF, 0x08, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xC9, 0xD8, 0x12, 0x00, 0x28, 0x00, 0x00, 0xF6, 0x63, 0x03,
     0x00, 0x00, 0x04, 0x03, 0x00, 0x00, 0x0A, 0x7E, 0x61, 0x2B},

    // 包 5: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x37, 0xCD, 0x77, 0x25, 0xD0, 0x91,
     0x0C, 0xA1, 0xA8, 0x74, 0xF4, 0x02, 0x8A, 0x9D, 0x9F, 0x37, 0x78, 0xF0,
     0x14, 0xB9, 0x64, 0x82, 0xCC, 0x27, 0x1F, 0xED, 0x89, 0x6C, 0x86, 0xAB,
     0xFF, 0xFF, 0xB9, 0x2B, 0x39, 0x01, 0x6D, 0xFE, 0xB0, 0x12, 0x11, 0x1B,
     0x1E, 0xFE, 0x26, 0x00, 0x28, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x3B, 0x10, 0xF9, 0xFF, 0xF8, 0xFF, 0x00, 0xE9, 0x3F, 0x00,
     0x00, 0x00, 0x05, 0x03, 0x00, 0x00, 0xB6, 0x9A, 0xF7, 0x51},

    // 包 6: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xE6, 0x95, 0xA4, 0x5E, 0x6C, 0xA5,
     0x0C, 0xA1, 0x57, 0x1D, 0xB6, 0x01, 0x1E, 0x49, 0xF7, 0xE5, 0x56, 0xBA,
     0xFC, 0x5B, 0x76, 0xBE, 0x45, 0x28, 0x02, 0x33, 0xA0, 0x44, 0x33, 0xAA,
     0xFF, 0xFF, 0x47, 0x2C, 0x1F, 0xFD, 0x02, 0xFA, 0x1F, 0x0E, 0x03, 0x21,
     0x86, 0xF8, 0x30, 0x00, 0x0D, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x05, 0x25, 0xF3, 0xFF, 0x63, 0xFF, 0x00, 0x08, 0x3A, 0x00,
     0x00, 0x00, 0x06, 0x03, 0x00, 0x00, 0x14, 0x2C, 0x51, 0xC4},

    // 包 7: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x35, 0xBE, 0xC8, 0x6F, 0x44, 0xBF,
     0x0D, 0xA1, 0x4D, 0x6F, 0x1A, 0x0A, 0x5B, 0x33, 0xC7, 0xAC, 0x85, 0x7A,
     0x57, 0x39, 0x82, 0xE3, 0xB5, 0x26, 0xD8, 0x65, 0xC4, 0xC3, 0x16, 0xA5,
     0xFF, 0xFF, 0xFC, 0x33, 0xAD, 0xFB, 0x87, 0xFB, 0x60, 0x13, 0x41, 0x19,
     0x0B, 0xFB, 0x30, 0xFF, 0xAC, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x36, 0xE3, 0xFE, 0xFF, 0xE1, 0xFF, 0x00, 0xE9, 0x62, 0x00,
     0x00, 0x00, 0x07, 0x03, 0x00, 0x00, 0xB2, 0x7C, 0x99, 0xE6},

    // 包 8: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x4A, 0xB6, 0xE8, 0xBA, 0x4F, 0x8B,
     0x0C, 0xA1, 0x06, 0x24, 0x5E, 0x05, 0x4A, 0xE0, 0x9B, 0x12, 0x6B, 0x2E,
     0xCE, 0xA9, 0xDA, 0xE1, 0x9C, 0x26, 0xA3, 0x1C, 0x67, 0x17, 0x81, 0xA3,
     0xFF, 0xFF, 0x43, 0x38, 0x59, 0x02, 0xDA, 0x03, 0x95, 0x07, 0xEA, 0x25,
     0x28, 0x05, 0x23, 0x00, 0xA7, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x00, 0x2C, 0x11, 0x00, 0x16, 0x00, 0x00, 0x0A, 0x1A, 0x00,
     0x00, 0x00, 0x08, 0x03, 0x00, 0x00, 0xDC, 0x6C, 0xD9, 0x7C},

    // 包 9: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xFB, 0x42, 0x46, 0x86, 0x9E, 0x8D,
     0x0D, 0xA1, 0xA1, 0xE5, 0x97, 0x01, 0xA4, 0x9D, 0x45, 0x51, 0xA1, 0x41,
     0xF8, 0xC3, 0x03, 0x51, 0x31, 0x27, 0x92, 0xAC, 0x0B, 0x98, 0x3D, 0xA6,
     0xFF, 0xFF, 0xEC, 0x33, 0x11, 0x01, 0x7E, 0xFF, 0x20, 0x0C, 0x78, 0x21,
     0x84, 0xFF, 0xE4, 0xFF, 0x17, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xA1, 0x2F, 0x16, 0x00, 0x52, 0x00, 0x00, 0x01, 0x03, 0x00,
     0x00, 0x00, 0x09, 0x03, 0x00, 0x00, 0x3E, 0x86, 0x94, 0x13},

    // 包 10: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xF3, 0x2A, 0xFE, 0xF6, 0x23, 0x3A,
     0x0D, 0xA1, 0xB1, 0xAE, 0x33, 0x05, 0x8C, 0x8B, 0xB7, 0xA1, 0x8F, 0x61,
     0xF5, 0xFD, 0x20, 0x86, 0x52, 0x28, 0x80, 0xAD, 0xB9, 0x6E, 0xA5, 0xA9,
     0xFF, 0xFF, 0x5A, 0x2A, 0x85, 0x01, 0x51, 0xFF, 0xBF, 0x12, 0x9C, 0x1B,
     0x4B, 0xFF, 0x0E, 0x00, 0x40, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x76, 0x6A, 0xF1, 0xFF, 0x9C, 0xFF, 0x00, 0x05, 0x6E, 0x00,
     0x00, 0x00, 0x0A, 0x03, 0x00, 0x00, 0x2E, 0x56, 0x04, 0xF5},

    // 包 11: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xFD, 0xA0, 0xE8, 0x2C, 0x68, 0x5B,
     0x0D, 0xA1, 0x1A, 0xED, 0xEA, 0x00, 0xBE, 0xB1, 0x5C, 0x9D, 0x38, 0x0D,
     0xC0, 0x8E, 0xFE, 0x79, 0x53, 0x27, 0x72, 0x58, 0xA2, 0x45, 0x7F, 0xA7,
     0xFF, 0xFF, 0x32, 0x31, 0x80, 0xFD, 0x9B, 0xF9, 0x00, 0x0E, 0x72, 0x1F,
     0x65, 0xF8, 0x04, 0x00, 0xCD, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x09, 0x0C, 0xE9, 0xFF, 0x41, 0x00, 0x00, 0xED, 0x1E, 0x01,
     0x00, 0x00, 0x0B, 0x03, 0x00, 0x00, 0x42, 0x42, 0xD9, 0x60},

    // 包 12: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x70, 0x65, 0x33, 0x19, 0x1D, 0x7A,
     0x0D, 0xA1, 0x13, 0x88, 0x7D, 0x04, 0xD5, 0xF9, 0x7D, 0x3D, 0xE6, 0x4A,
     0x1E, 0x1C, 0xC5, 0x23, 0x22, 0x27, 0x7D, 0x7A, 0x44, 0xF1, 0xB4, 0xA6,
     0xFF, 0xFF, 0xA0, 0x30, 0x57, 0x01, 0xA5, 0x06, 0x3C, 0x12, 0x42, 0x1A,
     0xE9, 0x07, 0xC0, 0xFF, 0xF8, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x21, 0xC0, 0xEC, 0xFF, 0xF3, 0xFF, 0x00, 0xE5, 0x48, 0x00,
     0x01, 0x00, 0x0C, 0x03, 0x00, 0x00, 0x28, 0xCB, 0x6E, 0x39},

    // 包 13: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xE4, 0x69, 0xCA, 0x28, 0xFC, 0x6E,
     0x0D, 0xA1, 0x75, 0x92, 0xBD, 0x04, 0x70, 0x8B, 0x02, 0x27, 0xB6, 0xFE,
     0xF9, 0xA2, 0xD8, 0x0D, 0xAE, 0x27, 0xFC, 0x13, 0x07, 0x9F, 0x82, 0xAA,
     0xFF, 0xFF, 0xF5, 0x2E, 0xCF, 0x00, 0xD3, 0xFD, 0xF5, 0x0B, 0x90, 0x22,
     0x5E, 0xFD, 0x1D, 0x00, 0xD2, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x8A, 0xFA, 0x16, 0x00, 0x00, 0x00, 0x00, 0xE7, 0x0B, 0x00,
     0x00, 0x00, 0x0D, 0x03, 0x00, 0x00, 0x10, 0xD4, 0x9C, 0x58},

    // 包 14: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xCD, 0x9A, 0xE9, 0x6A, 0x12, 0xBF,
     0x0D, 0xA1, 0x94, 0xE3, 0x02, 0x03, 0x10, 0x6A, 0xF5, 0x8D, 0x1E, 0xBE,
     0x80, 0x16, 0x6E, 0xE9, 0x73, 0x26, 0xC2, 0xA6, 0x37, 0xEF, 0x80, 0xA6,
     0xFF, 0xFF, 0xAB, 0x34, 0x83, 0x01, 0xEC, 0x06, 0xDB, 0x12, 0xC3, 0x18,
     0xCA, 0x07, 0x11, 0x00, 0x38, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x0A, 0x7B, 0x15, 0x00, 0x2E, 0x00, 0x00, 0xEF, 0xB8, 0x01,
     0x00, 0x00, 0x0E, 0x03, 0x00, 0x00, 0xE2, 0x35, 0xDB, 0xDC},

    // 包 15: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x42, 0xDF, 0xE6, 0x16, 0x09, 0xB9,
     0x0C, 0xA1, 0xBE, 0x05, 0x58, 0x08, 0x58, 0x04, 0xE9, 0x39, 0x4A, 0x14,
     0xAD, 0x82, 0xC5, 0x3F, 0x47, 0x26, 0xAE, 0x0B, 0x73, 0x92, 0x72, 0xA7,
     0xFF, 0xFF, 0x2D, 0x37, 0xAF, 0x01, 0xC0, 0xFF, 0xAF, 0x0B, 0x5A, 0x20,
     0x99, 0xFF, 0x83, 0x00, 0xEE, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xE1, 0xF4, 0x09, 0x00, 0x24, 0x00, 0x00, 0xEA, 0x36, 0x00,
     0x00, 0x00, 0x0F, 0x03, 0x00, 0x00, 0xCC, 0xBE, 0xD5, 0x34},

    // 包 16: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xD9, 0x2E, 0x7B, 0xC4, 0x8C, 0x03,
     0x0E, 0xA1, 0xD6, 0x5D, 0x65, 0x07, 0x14, 0x01, 0x11, 0x24, 0xE0, 0xA7,
     0x38, 0xD5, 0x23, 0xAF, 0x1A, 0x27, 0x3D, 0xA8, 0xF9, 0xF1, 0x59, 0xA7,
     0xFF, 0xFF, 0x98, 0x30, 0x4D, 0x02, 0x1B, 0x09, 0xF1, 0x11, 0x50, 0x1A,
     0xA8, 0x09, 0x8E, 0x00, 0x81, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xD9, 0x08, 0x01, 0x00, 0x4B, 0x00, 0x00, 0xEA, 0x25, 0x00,
     0x00, 0x00, 0x10, 0x03, 0x00, 0x00, 0xFA, 0x5D, 0xFE, 0x8F},

    // 包 17: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xBC, 0xB2, 0xF5, 0x5C, 0x16, 0x90,
     0x0D, 0xA1, 0x63, 0x9C, 0xAE, 0x06, 0x6B, 0xC0, 0x97, 0xCE, 0x0E, 0x59,
     0x09, 0xAD, 0x2A, 0xE6, 0x40, 0x27, 0xB9, 0x96, 0x7F, 0x1B, 0x83, 0xA6,
     0xFF, 0xFF, 0xE9, 0x33, 0xDA, 0x00, 0x81, 0x04, 0xA5, 0x07, 0xEB, 0x26,
     0x5D, 0x04, 0x04, 0x00, 0xB1, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xF7, 0x21, 0x08, 0x00, 0x67, 0xFF, 0x00, 0xE8, 0xBC, 0x00,
     0x00, 0x00, 0x11, 0x03, 0x00, 0x00, 0xC0, 0x65, 0xF3, 0xC0},

    // 包 18: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x2A, 0xDF, 0x07, 0xF8, 0x69, 0x8B,
     0x0D, 0xA1, 0x89, 0xB0, 0xA3, 0x02, 0x85, 0x86, 0x74, 0x87, 0x61, 0xD9,
     0xD7, 0x6A, 0x2D, 0x87, 0xA8, 0x27, 0xF6, 0x26, 0x93, 0x44, 0x1A, 0xA9,
     0xFF, 0xFF, 0x3A, 0x2F, 0x6C, 0xFE, 0xA6, 0xFA, 0x79, 0x0E, 0xFB, 0x1F,
     0xBB, 0xF9, 0xB7, 0xFF, 0xFF, 0xFF, 0x17, 0x63, 0x41, 0x01, 0x17, 0x63,
     0x00, 0x00, 0x26, 0xD6, 0xEB, 0xFF, 0x31, 0x00, 0x00, 0xEE, 0xEC, 0x02,
     0x00, 0x00, 0x12, 0x03, 0x00, 0x00, 0x9C, 0xBE, 0x17, 0xF7},

    // 包 19: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xAE, 0x51, 0xB9, 0x40, 0x19, 0x14,
     0x0D, 0xA1, 0x94, 0x74, 0x6F, 0x05, 0xFA, 0x16, 0x67, 0x71, 0x82, 0x25,
     0x9A, 0xF8, 0x60, 0x7B, 0x38, 0x27, 0x1A, 0x77, 0x4B, 0x1D, 0x35, 0xA3,
     0xFF, 0xFF, 0x6F, 0x35, 0xD7, 0x00, 0x90, 0x02, 0xB6, 0x07, 0xB4, 0x26,
     0x00, 0x03, 0x42, 0x00, 0xD4, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x9A, 0xCF, 0x14, 0x00, 0x1E, 0x00, 0x00, 0xDF, 0x36, 0x00,
     0x00, 0x00, 0x13, 0x03, 0x00, 0x00, 0xA4, 0xA3, 0x7A, 0x88},

    // 包 20: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x1E, 0xDC, 0xBF, 0x37, 0x63, 0x4B,
     0x0E, 0xA1, 0x0C, 0x25, 0xC6, 0x01, 0x62, 0x91, 0x00, 0xA4, 0x43, 0xF5,
     0xC8, 0x63, 0x78, 0xA7, 0x10, 0x27, 0xFC, 0x96, 0x06, 0x67, 0x76, 0xA9,
     0xFF, 0xFF, 0x01, 0x30, 0x5A, 0x00, 0xEC, 0xFC, 0xBD, 0x12, 0x8B, 0x19,
     0xCF, 0xFC, 0xF3, 0xFF, 0xD4, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xB1, 0xEE, 0x0B, 0x00, 0xFF, 0xFF, 0x00, 0xEE, 0x11, 0x00,
     0x00, 0x00, 0x14, 0x03, 0x00, 0x00, 0x84, 0xB8, 0x87, 0x76},

    // 包 21: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xB2, 0xFE, 0x4B, 0x19, 0x1D, 0x62,
     0x06, 0xA1, 0x77, 0xDD, 0x2A, 0x0D, 0xBC, 0x5E, 0x6A, 0xEF, 0x3B, 0xB9,
     0xFF, 0xAB, 0x7C, 0x0B, 0x20, 0x27, 0x18, 0x8F, 0xD5, 0x6D, 0x6D, 0xA6,
     0xFF, 0xFF, 0xDD, 0x31, 0xD5, 0x00, 0x48, 0x05, 0xEF, 0x09, 0xE2, 0x24,
     0xF1, 0x05, 0xC5, 0xFE, 0xBE, 0xFF, 0x0C, 0x7B, 0x41, 0x01, 0x0C, 0x7B,
     0x00, 0x00, 0xE6, 0x11, 0x03, 0x00, 0xE7, 0xFF, 0x00, 0xEA, 0x60, 0x00,
     0x01, 0x3F, 0x15, 0x03, 0x00, 0x00, 0xAC, 0xFD, 0x9F, 0x39},

    // 包 22: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x48, 0x52, 0x43, 0x60, 0x07, 0x44,
     0x0D, 0xA1, 0x9E, 0x3C, 0xB6, 0x06, 0xE2, 0x12, 0xC5, 0xD4, 0xC8, 0xC8,
     0x35, 0xC2, 0x47, 0x5A, 0x14, 0x27, 0xB3, 0x38, 0x1C, 0xF2, 0xB2, 0xA7,
     0xFF, 0xFF, 0xDD, 0x30, 0x9B, 0x02, 0x07, 0x08, 0x6D, 0x13, 0xB4, 0x19,
     0xDA, 0x08, 0x5C, 0xFF, 0x33, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x2B, 0xA1, 0xFC, 0xFF, 0x03, 0x00, 0x00, 0xE8, 0x35, 0x00,
     0x00, 0x00, 0x16, 0x03, 0x00, 0x00, 0xD8, 0xA4, 0x8E, 0xC7},

    // 包 23: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x13, 0xCC, 0xBE, 0xF5, 0x33, 0x38,
     0x0D, 0xA1, 0xC0, 0xD1, 0xAE, 0x02, 0x38, 0x22, 0x01, 0x8C, 0x60, 0x3A,
     0x93, 0x2E, 0x52, 0x0D, 0x1F, 0x28, 0xB3, 0x96, 0x78, 0x6D, 0xCD, 0xAA,
     0xFF, 0xFF, 0x51, 0x2B, 0xD2, 0x00, 0x38, 0xFF, 0xB5, 0x12, 0x8F, 0x1B,
     0xC8, 0xFE, 0xFF, 0xFF, 0x34, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x6A, 0x08, 0x10, 0x00, 0x39, 0x00, 0x00, 0xEE, 0x05, 0x00,
     0x00, 0x00, 0x17, 0x03, 0x00, 0x00, 0x6E, 0x98, 0x85, 0xF2},

    // 包 24: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x15, 0xCC, 0x77, 0x2B, 0x83, 0x6A,
     0x0D, 0xA1, 0x9D, 0x16, 0x93, 0x08, 0xB7, 0x2C, 0x54, 0x2B, 0xBA, 0xF1,
     0xF9, 0x60, 0x16, 0x5E, 0x0D, 0x26, 0x0E, 0xC8, 0x8A, 0xBF, 0xEF, 0xA7,
     0xFF, 0xFF, 0x06, 0x36, 0xF8, 0xFD, 0x11, 0xFC, 0x76, 0x10, 0x8C, 0x1A,
     0xDE, 0xFB, 0x34, 0x00, 0x6F, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x48, 0x49, 0xF3, 0xFF, 0x49, 0x00, 0x00, 0x05, 0x11, 0x00,
     0x00, 0x00, 0x18, 0x03, 0x00, 0x00, 0x72, 0x98, 0xF7, 0x5D},

    // 包 25: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x8C, 0x69, 0xF1, 0x2A, 0xB3, 0x00,
     0x0D, 0xA1, 0xF1, 0xA7, 0x47, 0x06, 0x4E, 0x3F, 0xD4, 0x2D, 0x9E, 0xB6,
     0x29, 0x19, 0x5C, 0x53, 0xA6, 0x26, 0xF1, 0xD0, 0x91, 0xED, 0x27, 0xA5,
     0xFF, 0xFF, 0xB6, 0x33, 0x3D, 0x00, 0x84, 0x06, 0xD3, 0x12, 0x28, 0x19,
     0xE9, 0x07, 0x9E, 0xFF, 0x1A, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x44, 0xE6, 0x0F, 0x00, 0xF5, 0xFF, 0x00, 0x0C, 0x56, 0x00,
     0x00, 0x00, 0x19, 0x03, 0x00, 0x00, 0x60, 0xD3, 0xEA, 0x5C},

    // 包 26: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x12, 0xDE, 0x31, 0xF3, 0x4D, 0xB0,
     0x0C, 0xA1, 0x74, 0xFB, 0x20, 0x05, 0x7F, 0x45, 0xB9, 0x19, 0x77, 0x16,
     0x33, 0xF6, 0x5E, 0x2D, 0xDD, 0x25, 0x8E, 0xBD, 0xBD, 0xEA, 0x29, 0xA3,
     0xFF, 0xFF, 0xF0, 0x37, 0x7C, 0x01, 0x80, 0x07, 0x4B, 0x13, 0x4A, 0x17,
     0x3B, 0x08, 0x36, 0x00, 0x41, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xB7, 0x29, 0xF7, 0xFF, 0x82, 0xFF, 0x00, 0x0E, 0x23, 0x00,
     0x00, 0x00, 0x1A, 0x03, 0x00, 0x00, 0x6C, 0xBC, 0x6B, 0xED},

    // 包 27: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x55, 0xD3, 0xFD, 0xCD, 0xB8, 0x8B,
     0x0D, 0xA1, 0x12, 0xF1, 0xE4, 0x06, 0x06, 0xB8, 0x9B, 0x22, 0x37, 0x77,
     0x71, 0xAF, 0xF4, 0x71, 0xFB, 0x26, 0xF1, 0xB7, 0x9C, 0x18, 0x7D, 0xA5,
     0xFF, 0xFF, 0xA8, 0x35, 0x74, 0x02, 0xBC, 0x03, 0x32, 0x07, 0x77, 0x26,
     0xA8, 0x04, 0x5A, 0x00, 0xD7, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xA4, 0x2F, 0xFF, 0xFF, 0x05, 0x00, 0x00, 0x05, 0x13, 0x00,
     0x00, 0x00, 0x1B, 0x03, 0x00, 0x00, 0xF2, 0xA6, 0x03, 0xA3},

    // 包 28: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xBD, 0x17, 0x0D, 0xCC, 0x1C, 0xF6,
     0x0C, 0xA1, 0x11, 0x43, 0x26, 0x00, 0xA0, 0xCF, 0xDE, 0x04, 0xA5, 0x0D,
     0xB6, 0x42, 0xA5, 0xC3, 0x28, 0x27, 0x0F, 0xD3, 0x97, 0xC2, 0x44, 0xA9,
     0xFF, 0xFF, 0x49, 0x30, 0x14, 0xFD, 0x85, 0xFD, 0x53, 0x12, 0x81, 0x1A,
     0xFB, 0xFC, 0xFA, 0xFF, 0xF2, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xFD, 0xAD, 0xEB, 0xFF, 0xDB, 0xFF, 0x00, 0xEC, 0x36, 0x03,
     0x00, 0x00, 0x1C, 0x03, 0x00, 0x00, 0xC2, 0x2F, 0x22, 0x9F},

    // 包 29: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x87, 0xFC, 0x49, 0xF6, 0x5F, 0x1F,
     0x0D, 0xA1, 0x22, 0x0B, 0xB0, 0x01, 0x0A, 0x03, 0x1B, 0x6D, 0x5F, 0x5A,
     0x02, 0xAA, 0xFB, 0x92, 0x5B, 0x27, 0xAC, 0x6B, 0x26, 0x1C, 0xB3, 0xA5,
     0xFF, 0xFF, 0xA7, 0x33, 0xA6, 0x00, 0xF8, 0x02, 0xE3, 0x08, 0x4D, 0x26,
     0x44, 0x03, 0xD8, 0xFF, 0xEE, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x3D, 0xAB, 0xEF, 0xFF, 0x28, 0x00, 0x00, 0xEB, 0x1D, 0x00,
     0x00, 0x00, 0x1D, 0x03, 0x00, 0x00, 0x56, 0xF9, 0x9B, 0xF3},

    // 包 30: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x7D, 0x3D, 0xFA, 0x72, 0xE4, 0x65,
     0x0D, 0xA1, 0x9A, 0x51, 0xF2, 0x03, 0x8A, 0xE0, 0xBA, 0x9F, 0xFF, 0x17,
     0x76, 0x31, 0x11, 0x86, 0x1B, 0x26, 0x35, 0x73, 0x90, 0xC3, 0x31, 0xA5,
     0xFF, 0xFF, 0x11, 0x37, 0xB9, 0xFB, 0x93, 0xFC, 0x6F, 0x12, 0xED, 0x18,
     0xD1, 0xFB, 0xB0, 0xFF, 0xE5, 0xFF, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x4C, 0xDA, 0xFB, 0xFF, 0x57, 0x00, 0x00, 0x08, 0x1D, 0x00,
     0x00, 0x00, 0x1E, 0x03, 0x00, 0x00, 0x42, 0x7B, 0xFC, 0xEC},

    // 包 31: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0xEA, 0x67, 0x20, 0xB9, 0x03, 0x65,
     0x0D, 0xA1, 0xB2, 0x76, 0x69, 0x05, 0x21, 0x1C, 0x8D, 0x21, 0x32, 0x15,
     0xA4, 0x13, 0x6F, 0x36, 0xDE, 0x26, 0x7D, 0x22, 0xB5, 0xC4, 0x32, 0xA7,
     0xFF, 0xFF, 0xBB, 0x31, 0x95, 0xFC, 0x37, 0xFE, 0x28, 0x13, 0x25, 0x19,
     0x8E, 0xFD, 0xB5, 0xFF, 0x5D, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0xBB, 0x49, 0xF9, 0xFF, 0x0B, 0x00, 0x00, 0xE3, 0x33, 0x00,
     0x00, 0x00, 0x1F, 0x03, 0x00, 0x00, 0x1C, 0xD0, 0x48, 0x79},

    // 包 32: MSG_GPSEPH (Class=0x08, ID=0x07)
    {0xBA, 0xCE, 0x48, 0x00, 0x08, 0x07, 0x53, 0x4C, 0x3F, 0xE9, 0x00, 0xE1,
     0x0C, 0xA1, 0x9C, 0xEF, 0x62, 0x04, 0xF8, 0x6D, 0x32, 0xAC, 0xB1, 0xE1,
     0xF8, 0xC8, 0xCC, 0x9C, 0x52, 0x27, 0xF6, 0xF2, 0xB2, 0x98, 0x19, 0xA7,
     0xFF, 0xFF, 0xB0, 0x32, 0x16, 0x00, 0xCA, 0xFE, 0x6C, 0x0C, 0xAB, 0x21,
     0x99, 0xFE, 0x69, 0x00, 0x4F, 0x00, 0x70, 0x62, 0x41, 0x01, 0x70, 0x62,
     0x00, 0x00, 0x2F, 0xD9, 0xF1, 0xFF, 0x60, 0x00, 0x00, 0x02, 0x16, 0x00,
     0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0xEE, 0x98, 0x86, 0xD9},

    // 包 33: MSG_GPSION (Class=0x08, ID=0x06)
    {0xBA, 0xCE, 0x10, 0x00, 0x08, 0x06, 0x4B, 0x0C, 0xFC,
     0xF9, 0x11, 0x03, 0xFE, 0xFE, 0x37, 0x09, 0xFE, 0xFA,
     0x03, 0x00, 0x00, 0x00, 0xA6, 0x18, 0x00, 0xFA}};
static size_t AGNSS_Current_Message_Index = 0;
static uint8_t AGNSS_Current_Message_Retry_Count = 0;
static GpsState_t AGNSS_Previous_State = S2_IDLE_GPS_OFF;
// Tracks if the *very first* fix attempt (cold start) has been tried since init
// or a long sleep. This helps decide T_GPS_COLD_START_FIX_TIMEOUT vs
// T_GPS_REACQUIRE_FIX_TIMEOUT.
static bool isFirstFixAttemptCycle = true;

// --- Helper Function to reset all timers (used when changing states often) ---
static void resetAllStateTimers() {
  Stillness_Confirm_Timer_Start = 0;
  Active_Sampling_Timer_Start = 0;
  Fix_Attempt_Timer_Start = 0;
  Periodic_Wake_Timer_Start = 0;
  GPS_Query_Timeout_Timer_S4_Start = 0;
  AGNSS_Message_Timer_Start = 0;
  AGNSS_Total_Timer_Start = 0;
}

// --- Function to explicitly power on the GPS module ---
void powerOnGPS() {
#ifdef PIN_GPS_EN
  pinMode(PIN_GPS_EN, OUTPUT);
  digitalWrite(PIN_GPS_EN, HIGH); // Assuming HIGH turns GPS ON
  Log.println("GPS Power ON");
  isGpsPoweredOn = true; // Track that GPS is powered on
  delay(100);            // Small delay for module to stabilize
#else
  Log.println("Warning: PIN_GPS_EN not defined. Cannot control GPS power.");
#endif
}

// --- Function to explicitly power off the GPS module ---
void powerOffGPS() {
#ifdef PIN_GPS_EN
  pinMode(PIN_GPS_EN, OUTPUT);
  digitalWrite(PIN_GPS_EN, LOW); // Assuming LOW turns GPS OFF
  Log.println("GPS Power OFF");
  isGpsPoweredOn = false; // Track that GPS is powered off
#else
  Log.println("Warning: PIN_GPS_EN not defined. Cannot control GPS power.");
#endif
  // Reset GPS data when turning off to avoid showing stale data
  gpsWrapper.reset(); // Clears internal TinyGPS++ state and CASIC parser
  // Explicitly clear relevant gSystemInfo fields related to current fix
  gSystemInfo.locationValid = false;
  gSystemInfo.dateTimeValid = false;
  gSystemInfo.latitude = 0.0;
  gSystemInfo.longitude = 0.0;
  gSystemInfo.altitude = 0.0f;
  gSystemInfo.satellites = 0;
  gSystemInfo.hdop = 99.9f;
  gSystemInfo.speed = -1.0f;
  gSystemInfo.course = -1.0f;
  gSystemInfo.year = 0;
  gSystemInfo.month = 0;
  gSystemInfo.day = 0;
  gSystemInfo.hour = 0;
  gSystemInfo.minute = 0;
  gSystemInfo.second = 0;
}

// --- AGNSS related helper functions ---
static void initAgnssVariables() {
  AGNSS_Current_Message_Index = 0;
  AGNSS_Current_Message_Retry_Count = 0;
  AGNSS_Message_Timer_Start = 0;
  AGNSS_Total_Timer_Start = 0;
}

static void sendCurrentAgnssMessage() {
  if (AGNSS_Current_Message_Index < AGNSS_Message_Queue.size()) {
    const auto &message = AGNSS_Message_Queue[AGNSS_Current_Message_Index];
    auto len = gpsSerial.write(message.data(), message.size());
    if (len != message.size()) {
      Log.printf(
          "AGNSS: Failed to send message %d, expected %d bytes, sent %d\n",
          (int)AGNSS_Current_Message_Index, (int)message.size(), (int)len);
      AGNSS_Current_Message_Retry_Count++;
    } else {
      Log.printf("AGNSS: Successfully sent message %d, size %d bytes\n",
                 (int)AGNSS_Current_Message_Index, (int)len);
    }
    Log.printf("AGNSS: Sent message %d/%d (retry %d)\n",
               (int)(AGNSS_Current_Message_Index + 1),
               (int)AGNSS_Message_Queue.size(),
               AGNSS_Current_Message_Retry_Count);
  }
}

// Helper function to check if AGNSS should be triggered
static bool shouldTriggerAgnss() {
  return millis() > 10 * 1000 && AGNSS_Request_Pending &&
         !AGNSS_Message_Queue.empty() &&
         gSystemInfo.gpsState != S5_AGNSS_PROCESSING;
}

static void transitionBackFromAgnss(unsigned long now) {
  // Clean up AGNSS state
  AGNSS_Message_Queue.clear();
  initAgnssVariables();

  // Transition back based on previous state
  switch (AGNSS_Previous_State) {
  case S1_GPS_SEARCHING_FIX:
    Fix_Attempt_Timer_Start = now;
    gSystemInfo.gpsState = S1_GPS_SEARCHING_FIX;
    Log.println("GPS State: S5 -> S1_GPS_SEARCHING_FIX (AGNSS complete)");
    break;
  case S2_IDLE_GPS_OFF:
    powerOffGPS();
    Periodic_Wake_Timer_Start = now;
    gSystemInfo.gpsState = S2_IDLE_GPS_OFF;
    Log.println("GPS State: S5 -> S2_IDLE_GPS_OFF (AGNSS complete)");
    break;
  case S3_TRACKING_FIXED:
    Active_Sampling_Timer_Start = now;
    gSystemInfo.gpsState = S3_TRACKING_FIXED;
    Log.println("GPS State: S5 -> S3_TRACKING_FIXED (AGNSS complete)");
    break;
  case S4_ANALYZING_STILLNESS:
    GPS_Query_Timeout_Timer_S4_Start = now;
    gSystemInfo.gpsState = S4_ANALYZING_STILLNESS;
    Log.println("GPS State: S5 -> S4_ANALYZING_STILLNESS (AGNSS complete)");
    break;
  default:
    // Fallback to idle state
    powerOffGPS();
    Periodic_Wake_Timer_Start = now;
    gSystemInfo.gpsState = S2_IDLE_GPS_OFF;
    Log.println("GPS State: S5 -> S2_IDLE_GPS_OFF (AGNSS fallback)");
    break;
  }
}

// --- Public function to set AGNSS message queue ---
void setAgnssMessageQueue(const std::vector<std::vector<uint8_t>> &messages) {
  AGNSS_Message_Queue = messages;
  if (!messages.empty()) {
    AGNSS_Request_Pending = true;
    Log.printf("AGNSS: Message queue set with %d messages, request pending\n",
               (int)messages.size());
  }
}

// --- Public function to trigger AGNSS processing ---
void triggerAgnssProcessing() {
  if (AGNSS_Message_Queue.empty()) {
    Log.println("AGNSS: No messages in queue, ignoring trigger");
    return;
  }

  if (gSystemInfo.gpsState == S5_AGNSS_PROCESSING) {
    Log.println("AGNSS: Already in AGNSS processing state");
    return;
  }

  unsigned long now = millis();
  AGNSS_Previous_State = gSystemInfo.gpsState;
  AGNSS_Request_Pending = false; // Clear the request flag

  Log.printf("AGNSS: Triggering processing, previous state: %d\n",
             AGNSS_Previous_State);

  // Stop current state timers
  resetAllStateTimers();

  // Ensure GPS is powered on
  if (!isGpsPoweredOn) {
    powerOnGPS();
  }

  // Initialize AGNSS processing
  initAgnssVariables();
  AGNSS_Total_Timer_Start = now;

  // Send first message
  sendCurrentAgnssMessage();
  AGNSS_Message_Timer_Start = now;

  gSystemInfo.gpsState = S5_AGNSS_PROCESSING;
  Log.printf("GPS State: %d -> S5_AGNSS_PROCESSING (AGNSS triggered)\n",
             AGNSS_Previous_State);
}

// --- Convenience function to set AGNSS data and trigger processing ---
void requestAgnssProcessing(const std::vector<std::vector<uint8_t>> &messages) {
  if (messages.empty()) {
    Log.println("AGNSS: Cannot request processing with empty message queue");
    return;
  }

  Log.printf("AGNSS: Requesting processing with %d messages\n",
             (int)messages.size());
  setAgnssMessageQueue(messages);
  // The AGNSS request flag is set by setAgnssMessageQueue,
  // and will be processed in the next handleGPS() call
}

// --- Function to initialize GPS communication and power pin ---
void initGPS() {
  gSystemInfo.gpsState = S0_INITIALIZING;
  Log.println("GPS State: S0_INITIALIZING");

  // Hardware reset for GPS module (if LORA_RESET is also for GPS)
#ifdef LORA_RESET // Assuming LORA_RESET might be used for GPS too, or a
                  // dedicated GPS_RESET_PIN
  pinMode(LORA_RESET, OUTPUT);
  digitalWrite(LORA_RESET, LOW);
  delay(100);
  digitalWrite(LORA_RESET, HIGH);
  Log.println("GPS Module Reset via LORA_RESET pin.");
#else
  Log.println("Warning: LORA_RESET (for GPS) not defined.");
#endif

  gpsSerial.begin(GPS_DEFAULT_BAUD_RATE);
  gpsSerial.println("$PCAS04,7*1E"); // Configure for Beidou + GPS + GLONASS
  gpsSerial.println("$PCAS01,5*19"); // 115200 baud rate
  gpsSerial.end();
  delay(100);
  gpsSerial.begin(GPS_BAUD_RATE); // Reinitialize with new baud rate
  // gpsSerial.println("$PCAS02,100*1E");
  Log.println("GPS Serial Initialized, NMEA configured.");

#ifdef PIN_GPS_EN
  pinMode(PIN_GPS_EN, OUTPUT);
#endif

  // E0.1_Initialization_Complete: Default to power-saving start ->
  // S2_IDLE_GPS_OFF
  powerOffGPS();
  resetAllStateTimers();
  Periodic_Wake_Timer_Start = millis(); // Start periodic wake timer
  isFirstFixAttemptCycle = true;        // Next fix attempt will be a cold start
  gSystemInfo.gpsState = S2_IDLE_GPS_OFF;
  Log.println("GPS State: S0 -> S2_IDLE_GPS_OFF. Init complete.");
}

// --- Function to update the global gSystemInfo struct from TinyGPSPlus data
// ---
void updateGpsSystemInfo() {
  TinyGPSPlus &gps =
      gpsWrapper.getTinyGPS(); // Get TinyGPS++ instance from wrapper
  gSystemInfo.locationValid = gps.location.isValid();
  if (gSystemInfo.locationValid) {
    gSystemInfo.latitude = gps.location.lat();
    gSystemInfo.longitude = gps.location.lng();
    gSystemInfo.satellites = gps.satellites.value();
    gSystemInfo.altitude = gps.altitude.meters();
  } else {
    // Keep old values or reset? Spec implies reset if invalid.
    gSystemInfo.latitude = 0.0;
    gSystemInfo.longitude = 0.0;
    gSystemInfo.satellites =
        gps.satellites.isValid() ? gps.satellites.value() : 0;
    gSystemInfo.altitude = 0.0f;
  }

  if (gps.hdop.isValid()) {
    gSystemInfo.hdop = gps.hdop.value() / 100.0f;
  } else {
    gSystemInfo.hdop = 99.9f;
  }

  if (gps.speed.isValid()) {
    gSystemInfo.speed = gps.speed.kmph();
  } else {
    gSystemInfo.speed = -1.0f; // Invalid speed
  }

  if (gps.course.isValid()) {
    gSystemInfo.course = gps.course.deg();
  } else {
    gSystemInfo.course = -1.0f; // Invalid course
  }

  gSystemInfo.dateTimeValid = gps.date.isValid() && gps.time.isValid();
  if (gSystemInfo.dateTimeValid) {
    gSystemInfo.year = gps.date.year();
    gSystemInfo.month = gps.date.month();
    gSystemInfo.day = gps.date.day();
    gSystemInfo.hour = gps.time.hour();
    gSystemInfo.minute = gps.time.minute();
    gSystemInfo.second = gps.time.second();
  } else {
    gSystemInfo.year = 0;
    gSystemInfo.month = 0;
    gSystemInfo.day = 0;
    gSystemInfo.hour = 0;
    gSystemInfo.minute = 0;
    gSystemInfo.second = 0;
  }
}

// --- Helper function to convert GPS date/time to an approximate Unix timestamp
// ---
uint32_t dateTimeToUnixTimestamp(uint16_t year, uint8_t month, uint8_t day,
                                 uint8_t hour, uint8_t minute, uint8_t second) {
  if (year < 1970 || year > 2038)
    return 0;
  uint32_t days = (year - 1970) * 365;
  for (uint16_t y = 1972; y < year; y += 4)
    days++;                      // Add leap year days
  bool isLeap = (year % 4 == 0); // Simplified leap year check
  if (isLeap && month > 2)
    days++;
  const uint8_t daysInMonth[] = {0,  31, 28, 31, 30, 31, 30,
                                 31, 31, 30, 31, 30, 31};
  for (uint8_t m = 1; m < month; m++)
    days += daysInMonth[m];
  days += (day - 1);
  uint32_t seconds_val = days * 86400UL;
  seconds_val += hour * 3600UL;
  seconds_val += minute * 60UL;
  seconds_val += second;
  return seconds_val;
}

// --- Function to handle GPS state, data reading, parsing, power, and updating
// gSystemInfo ---
void handleGPS() {
  unsigned long now = millis();
  if (isGpsPoweredOn) {
    while (gpsSerial.available() > 0) {
      char byte = gpsSerial.read();
      // Log.print(byte);
      if (gpsWrapper.encode(byte)) {
        updateGpsSystemInfo();

        // 检查是否有新的CASIC数据
        if (gpsWrapper.isNewCasicData()) {
          CasicPacket packet = gpsWrapper.getLastCasicPacket();
          Log.printf("Received CASIC packet: Class=0x%02X, ID=0x%02X, Len=%d\n",
                     packet.class_id, packet.msg_id, packet.payload_length);

          // 非AGNSS状态下的常规处理（AGNSS状态下的处理在switch语句中进行）
          if (gSystemInfo.gpsState != S5_AGNSS_PROCESSING) {
            if (gpsWrapper.hasNewAck()) {
              Log.println("GPS ACK received");
            } else if (gpsWrapper.hasNewNack()) {
              Log.println("GPS NACK received");
            } else if (gpsWrapper.hasNewEphemeris()) {
              Log.println("GPS Ephemeris data received");
            }
            // 只在非AGNSS状态下清理数据
            gpsWrapper.clearCasicData();
          }
          // AGNSS状态下不清理数据，让switch语句中的逻辑处理
        }
      }
    }
  }

  switch (gSystemInfo.gpsState) {
  case S0_INITIALIZING: { // Should have transitioned out during initGPS(). If
                          // stuck, force to S2.
    Log.println("Warning: Still in S0_INITIALIZING in handleGPS. Forcing S2.");
    powerOffGPS();
    resetAllStateTimers();
    Periodic_Wake_Timer_Start = now;
    isFirstFixAttemptCycle = true;
    gSystemInfo.gpsState = S2_IDLE_GPS_OFF;
    break;
  }
  case S1_GPS_SEARCHING_FIX: { // Entry Actions (should be done when
                               // transitioning TO this state, but
    // double check if timer started)
    if (Fix_Attempt_Timer_Start == 0) {
      Log.println("S1: Fix_Attempt_Timer was 0, starting now.");
      Fix_Attempt_Timer_Start = now;
    }
    if (!isGpsPoweredOn)
      powerOnGPS(); // Ensure GPS is ON

    // E1.1_GPS_Fix_Acquired
    if (gSystemInfo.locationValid && gSystemInfo.dateTimeValid &&
        gSystemInfo.hdop <= MIN_HDOP_FOR_VALID_FIX) {
      Log.println("GPS State: S1 -> S3_TRACKING_FIXED (Fix Acquired)");
      resetAllStateTimers();
      Active_Sampling_Timer_Start = now;
      Consecutive_Fix_Failures_Counter = 0;
      isFirstFixAttemptCycle =
          false; // A fix was successful, subsequent ones are reacquires until
                 // next long sleep/init

      last_successful_position.timestamp = dateTimeToUnixTimestamp(
          gSystemInfo.year, gSystemInfo.month, gSystemInfo.day,
          gSystemInfo.hour, gSystemInfo.minute, gSystemInfo.second);
      last_successful_position.latitude = gSystemInfo.latitude;
      last_successful_position.longitude = gSystemInfo.longitude;
      last_successful_position.altitude_m = gSystemInfo.altitude;
      last_successful_position.hdop = gSystemInfo.hdop;

      gSystemInfo.gpsState = S3_TRACKING_FIXED;
      break; // Exit switch case for this iteration
    }

    // E1.2_Fix_Attempt_Timer_Expired
    unsigned long current_fix_timeout = isFirstFixAttemptCycle
                                            ? T_GPS_COLD_START_FIX_TIMEOUT
                                            : T_GPS_REACQUIRE_FIX_TIMEOUT;
    if (now - Fix_Attempt_Timer_Start >= current_fix_timeout) {
      Log.printf("S1: Fix Attempt Timer Expired (%lu ms). Failures: %d\n",
                 current_fix_timeout, Consecutive_Fix_Failures_Counter + 1);
      Consecutive_Fix_Failures_Counter++;
      if (Consecutive_Fix_Failures_Counter >= MAX_CONSECUTIVE_FIX_FAILURES) {
        Log.println(
            "Max consecutive fix failures reached. Sending GPS warm restart.");
        gpsSerial.println("$PCAS10,1*1D"); // Warm restart command
        Consecutive_Fix_Failures_Counter = 0;
      }
      powerOffGPS();
      resetAllStateTimers();
      Periodic_Wake_Timer_Start = now;
      isFirstFixAttemptCycle = true; // Next attempt after sleep will be cold.
      gSystemInfo.gpsState = S2_IDLE_GPS_OFF;
      Log.println("GPS State: S1 -> S2_IDLE_GPS_OFF (Fix Timeout)");
      break;
    }
    // E1.3 & E1.4 (Motion/Stillness during search) - Not explicitly handled to
    // change S1 behavior in this version.

    // E1.5_AGNSS_Request - Check for pending AGNSS request
    if (shouldTriggerAgnss()) {
      Log.println("GPS State: S1 -> S5_AGNSS_PROCESSING (AGNSS Request)");
      triggerAgnssProcessing();
      break;
    }
    break;
  }
  case S2_IDLE_GPS_OFF: {
    if (Periodic_Wake_Timer_Start == 0) {
      Periodic_Wake_Timer_Start = now;
    } // Safety for timer start
    if (isGpsPoweredOn)
      powerOffGPS(); // Ensure GPS is OFF

    // E2.1_Motion_Detected (gSystemInfo.isStationary is managed by accel
    // handler) If isStationary is false, it means motion is detected.
    if (!gSystemInfo.isStationary) {
      Log.println("GPS State: S2 -> S1_GPS_SEARCHING_FIX (Motion Detected)");
      powerOnGPS();
      resetAllStateTimers();
      Fix_Attempt_Timer_Start = now;
      // isFirstFixAttemptCycle remains true if it was, or false if a fix was
      // ever found before this sleep
      gSystemInfo.gpsState = S1_GPS_SEARCHING_FIX;
      break;
    }

    // E2.2_Periodic_Wake_Timer_Expired
    if (now - Periodic_Wake_Timer_Start >= T_GPS_SLEEP_PERIODIC_WAKE_INTERVAL) {
      Log.println("GPS State: S2 -> S1_GPS_SEARCHING_FIX (Periodic Wake)");
      powerOnGPS();
      resetAllStateTimers();
      Fix_Attempt_Timer_Start = now;
      isFirstFixAttemptCycle =
          true; // Waking from long sleep, assume cold start needed
      gSystemInfo.gpsState = S1_GPS_SEARCHING_FIX;
      break;
    }

    // E2.3_AGNSS_Request - Check for pending AGNSS request
    if (shouldTriggerAgnss()) {
      Log.println("GPS State: S2 -> S5_AGNSS_PROCESSING (AGNSS Request)");
      triggerAgnssProcessing();
      break;
    }
    break;
  }
  case S3_TRACKING_FIXED: {
    if (Active_Sampling_Timer_Start == 0) {
      Active_Sampling_Timer_Start = now;
    } // Safety
    if (!isGpsPoweredOn)
      powerOnGPS(); // Ensure GPS is ON

    // E3.5_GPS_Signal_Lost_Or_Degraded (Primary check)
    if (!(gSystemInfo.locationValid && gSystemInfo.dateTimeValid &&
          gSystemInfo.hdop <= MIN_HDOP_FOR_VALID_FIX)) {
      Log.println(
          "GPS State: S3 -> S1_GPS_SEARCHING_FIX (Signal Lost/Degraded)");
      resetAllStateTimers();
      Fix_Attempt_Timer_Start = now;
      // isFirstFixAttemptCycle should be false here, as we were just in S3
      gSystemInfo.gpsState = S1_GPS_SEARCHING_FIX;
      break;
    }

    // E3.1_Active_Sampling_Timer_Expired
    if (now - Active_Sampling_Timer_Start >= T_ACTIVE_SAMPLING_INTERVAL) {
      Log.println("S3: Active Sampling Timer. Logging GPX.");
      // Ensure data is still good before logging (already checked by E3.5, but
      // good practice)
      if (gSystemInfo.locationValid && gSystemInfo.dateTimeValid &&
          gSystemInfo.hdop <= MIN_HDOP_FOR_VALID_FIX) {
        last_successful_position.timestamp = dateTimeToUnixTimestamp(
            gSystemInfo.year, gSystemInfo.month, gSystemInfo.day,
            gSystemInfo.hour, gSystemInfo.minute, gSystemInfo.second);
        last_successful_position.latitude = gSystemInfo.latitude;
        last_successful_position.longitude = gSystemInfo.longitude;
        last_successful_position.altitude_m = gSystemInfo.altitude;
        last_successful_position.hdop = gSystemInfo.hdop;

        appendGpxPoint(last_successful_position.timestamp,
                       last_successful_position.latitude,
                       last_successful_position.longitude,
                       last_successful_position.altitude_m);
        Log.println("GPX Point logged in S3.");
      }
      Active_Sampling_Timer_Start = now; // Restart timer
    }

    // E3.2_Motion_Sensed / E3.3_Potential_Stillness_Sensed
    if (!gSystemInfo.isStationary) { // Motion
      if (Stillness_Confirm_Timer_Start != 0) {
        Log.println("S3: Motion, Stillness_Confirm_Timer reset.");
        Stillness_Confirm_Timer_Start = 0;
      }
    } else { // Potential Stillness (gSystemInfo.isStationary is true)
      if (Stillness_Confirm_Timer_Start == 0) {
        Log.println(
            "S3: Potential Stillness, Stillness_Confirm_Timer started.");
        Stillness_Confirm_Timer_Start = now;
      }
    }

    // E3.4_Stillness_Confirmed
    if (gSystemInfo.isStationary && Stillness_Confirm_Timer_Start != 0 &&
        (now - Stillness_Confirm_Timer_Start >= T_STILLNESS_CONFIRM_DURATION)) {
      Log.println(
          "GPS State: S3 -> S4_ANALYZING_STILLNESS (Stillness Confirmed)");
      resetAllStateTimers();
      GPS_Query_Timeout_Timer_S4_Start = now;
      gSystemInfo.gpsState = S4_ANALYZING_STILLNESS;
      // GPS remains ON for S4 analysis
      break;
    }

    // E3.6_AGNSS_Request - Check for pending AGNSS request
    if (shouldTriggerAgnss()) {
      Log.println("GPS State: S3 -> S5_AGNSS_PROCESSING (AGNSS Request)");
      triggerAgnssProcessing();
      break;
    }
    break;
  }
  case S4_ANALYZING_STILLNESS: {
    if (GPS_Query_Timeout_Timer_S4_Start == 0) {
      GPS_Query_Timeout_Timer_S4_Start = now;
    } // Safety
    if (!isGpsPoweredOn)
      powerOnGPS(); // Ensure GPS is ON for query

    // E4.1_Motion_Detected_During_Analysis
    if (!gSystemInfo.isStationary) {
      Log.println(
          "GPS State: S4 -> S3_TRACKING_FIXED (Motion during Analysis)");
      resetAllStateTimers();
      Active_Sampling_Timer_Start = now;
      gSystemInfo.gpsState = S3_TRACKING_FIXED;
      break;
    }

    // E4.2_GPS_Query_Results_Received (Implicitly, by checking gSystemInfo now)
    // AND E4.3_GPS_Query_Timeout_Timer_S4_Expired (Handled together)
    bool S4_timeout = (now - GPS_Query_Timeout_Timer_S4_Start >=
                       T_GPS_QUERY_TIMEOUT_FOR_STILLNESS);

    if (S4_timeout || gSystemInfo.locationValid) { // Process if timeout OR if
                                                   // data is valid for decision
      if (!S4_timeout && gSystemInfo.locationValid &&
          gSystemInfo.speed > GPS_SPEED_VEHICLE_THRESHOLD) {
        // Case 1: Traffic stop (vehicle still has GPS speed)
        Log.println("GPS State: S4 -> S3_TRACKING_FIXED (Vehicle Stop Analysis "
                    "- high GPS speed)");
        resetAllStateTimers();
        Active_Sampling_Timer_Start = now;
        gSystemInfo.gpsState = S3_TRACKING_FIXED;
      } else {
        // Case 2: Indoor/Signal Poor OR Outdoor Low Speed Stillness OR S4
        // Timeout
        if (S4_timeout)
          Log.println("S4: Query Timeout.");
        else
          Log.println("S4: Low GPS speed or poor signal.");

        Log.println("GPS State: S4 -> S2_IDLE_GPS_OFF");
        powerOffGPS();
        resetAllStateTimers();
        Periodic_Wake_Timer_Start = now;
        isFirstFixAttemptCycle = true; // Next attempt after sleep will be cold
        gSystemInfo.gpsState = S2_IDLE_GPS_OFF;
      }
      break;
    }
    // If not timed out and location is not yet valid, stay in S4 and wait for
    // GPS data or timeout.

    // E4.4_AGNSS_Request - Check for pending AGNSS request
    if (shouldTriggerAgnss()) {
      Log.println("GPS State: S4 -> S5_AGNSS_PROCESSING (AGNSS Request)");
      triggerAgnssProcessing();
      break;
    }
    break;
  }
  case S5_AGNSS_PROCESSING: {
    if (AGNSS_Total_Timer_Start == 0) {
      AGNSS_Total_Timer_Start = now;
    } // Safety for timer start
    if (!isGpsPoweredOn)
      powerOnGPS(); // Ensure GPS is ON

    // E5.1_AGNSS_ACK_Received
    if (gpsWrapper.isNewCasicData() && gpsWrapper.hasNewAck()) {
      Log.println("S5: ACK received for AGNSS message");
      gpsWrapper.clearCasicData();   // 立即清理数据
      AGNSS_Message_Timer_Start = 0; // Stop message timer
      AGNSS_Current_Message_Index++;
      AGNSS_Current_Message_Retry_Count = 0;

      if (AGNSS_Current_Message_Index >= AGNSS_Message_Queue.size()) {
        // All AGNSS messages successfully sent
        Log.println("S5: All AGNSS messages sent successfully");
        transitionBackFromAgnss(now);
      } else {
        // Send next AGNSS message
        sendCurrentAgnssMessage();
        AGNSS_Message_Timer_Start = now;
      }
      break;
    }

    // E5.2_AGNSS_NACK_Received
    if (gpsWrapper.isNewCasicData() && gpsWrapper.hasNewNack()) {
      Log.println("S5: NACK received for AGNSS message");
      gpsWrapper.clearCasicData();   // 立即清理数据
      AGNSS_Message_Timer_Start = 0; // Stop message timer
      AGNSS_Current_Message_Retry_Count++;

      if (AGNSS_Current_Message_Retry_Count >= MAX_AGNSS_MESSAGE_RETRY) {
        // Max retries reached, AGNSS processing failed
        Log.println("S5: Max retries reached, AGNSS processing failed");
        transitionBackFromAgnss(now);
      } else {
        // Retry sending current AGNSS message
        Log.printf("S5: Retrying AGNSS message (attempt %d/%d)\n",
                   AGNSS_Current_Message_Retry_Count + 1,
                   MAX_AGNSS_MESSAGE_RETRY);
        sendCurrentAgnssMessage();
        AGNSS_Message_Timer_Start = now;
      }
      break;
    }

    // E5.3_AGNSS_Message_Timer_Expired
    if (AGNSS_Message_Timer_Start != 0 &&
        now - AGNSS_Message_Timer_Start >= T_AGNSS_MESSAGE_SEND_TIMEOUT) {
      Log.println("S5: AGNSS message timer expired");
      AGNSS_Current_Message_Retry_Count++;

      if (AGNSS_Current_Message_Retry_Count >= MAX_AGNSS_MESSAGE_RETRY) {
        // Max retries reached, AGNSS processing failed
        Log.println(
            "S5: Max retries reached after timeout, AGNSS processing failed");
        transitionBackFromAgnss(now);
      } else {
        // Retry sending current AGNSS message
        Log.printf("S5: Retrying AGNSS message after timeout (attempt %d/%d)\n",
                   AGNSS_Current_Message_Retry_Count + 1,
                   MAX_AGNSS_MESSAGE_RETRY);
        sendCurrentAgnssMessage();
        AGNSS_Message_Timer_Start = now;
      }
      break;
    }

    // E5.4_AGNSS_Total_Timer_Expired
    if (now - AGNSS_Total_Timer_Start >= T_AGNSS_TOTAL_TIMEOUT) {
      Log.println("S5: AGNSS total timer expired, forcing completion");
      transitionBackFromAgnss(now);
      break;
    }

    // E5.5_Motion_Detected_During_AGNSS
    if (!gSystemInfo.isStationary) {
      // Motion detected during AGNSS processing
      // Update previous state to motion-related state for proper return
      if (AGNSS_Previous_State == S2_IDLE_GPS_OFF ||
          AGNSS_Previous_State == S4_ANALYZING_STILLNESS) {
        AGNSS_Previous_State =
            S3_TRACKING_FIXED; // Motion detected, should return to tracking
      }
      // Log motion but continue AGNSS processing
      Log.println("S5: Motion detected during AGNSS processing");
    }

    break;
  }
  default: {
    Log.printf("Error: Unknown GPS State (%d)! Resetting to S2_IDLE_GPS_OFF\n",
               gSystemInfo.gpsState);
    powerOffGPS();
    resetAllStateTimers();
    Periodic_Wake_Timer_Start = now;
    isFirstFixAttemptCycle = true;
    gSystemInfo.gpsState = S2_IDLE_GPS_OFF;
    break;
  }
  }
}
