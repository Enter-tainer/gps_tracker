<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Bluetooth File Explorer with GPX Conversion</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #f4f4f4;
      color: #333;
    }

    .container {
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    h1,
    h2 {
      color: #0056b3;
    }

    button,
    .action-button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      margin: 5px 2px;
      text-decoration: none;
      display: inline-block;
    }

    button:hover,
    .action-button:hover {
      background-color: #0056b3;
    }

    button:disabled,
    .action-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    #fileList,
    #messages {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #e9ecef;
      min-height: 100px;
      max-height: 300px;
      overflow-y: auto;
    }

    #fileList .file-entry {
      padding: 8px 5px;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #fileList .file-entry:last-child {
      border-bottom: none;
    }

    #fileList .file-name {
      flex-grow: 1;
    }

    #fileList .file-actions button,
    #fileList .file-actions .action-button {
      font-size: 0.8em;
      padding: 5px 8px;
    }

    .file-item-name {
      color: #007bff;
    }

    .dir-item-name {
      color: #28a745;
      cursor: pointer;
    }

    .dir-item-name:hover {
      text-decoration: underline;
    }

    .status {
      margin-top: 10px;
      font-style: italic;
    }

    .section {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    input[type="text"] {
      width: calc(100% - 22px);
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    #sysInfoDisplay {
      height: 420px;
    }

    #gpxViewer {
      height: 75vh;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Web Bluetooth File Explorer & GPX Converter</h1>

    <div class="section">
      <h2>1. Connection</h2>
      <button id="connectButton">Connect to Device</button>
      <button id="sysInfoButton" style="margin-left:10px;">Query Status</button>
      <button id="agnssButton" style="margin-left:10px;">Download & Send AGNSS</button>
      <div id="status" class="status">Disconnected</div>
      <div id="agnssStatus" class="status" style="display:none;">AGNSS Status: Ready</div>
      <div id="sysInfoDisplay">
        <div
          style="margin-top:10px;max-width:420px;background:#f8f9fa;border-radius:8px;padding:18px 20px;box-shadow:0 2px 8px #0001;">
          <h3 style='margin-top:0;color:#0056b3;'>设备系统信息</h3>
          <table style='width:100%;border-collapse:collapse;'>
            <tbody>
              <tr>
                <td><b>纬度</b></td>
                <td id="sysinfo-latitude">-</td>
              </tr>
              <tr>
                <td><b>经度</b></td>
                <td id="sysinfo-longitude">-</td>
              </tr>
              <tr>
                <td><b>海拔</b></td>
                <td id="sysinfo-altitude">-</td>
              </tr>
              <tr>
                <td><b>卫星数</b></td>
                <td id="sysinfo-satellites">-</td>
              </tr>
              <tr>
                <td><b>HDOP</b></td>
                <td id="sysinfo-hdop">-</td>
              </tr>
              <tr>
                <td><b>速度</b></td>
                <td id="sysinfo-speed">-</td>
              </tr>
              <tr>
                <td><b>航向</b></td>
                <td id="sysinfo-course">-</td>
              </tr>
              <tr>
                <td><b>日期</b></td>
                <td id="sysinfo-date">-</td>
              </tr>
              <tr>
                <td><b>时间</b></td>
                <td id="sysinfo-time">-</td>
              </tr>
              <tr>
                <td><b>定位有效</b></td>
                <td id="sysinfo-locationValid">-</td>
              </tr>
              <tr>
                <td><b>时间有效</b></td>
                <td id="sysinfo-dateTimeValid">-</td>
              </tr>
              <tr>
                <td><b>电池电压</b></td>
                <td id="sysinfo-batteryVoltage">-</td>
              </tr>
              <tr>
                <td><b>GPS状态</b></td>
                <td id="sysinfo-gpsState">-</td>
              </tr>
            </tbody>
          </table>
          <div id="sysinfo-error" style="color:#dc3545;margin-top:8px;"></div>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>2. File System</h2>
      <label for="currentPath">Current Path:</label>
      <input type="text" id="currentPath" value="/" readonly>
      <button id="listDirButton" disabled>List Directory</button>
      <div id="fileList">No files listed.</div>
    </div>

    <div class="section">
      <!-- 只保留 gpx-viewer 组件，移除原有地图/轨迹/进度条等控件 -->
      <gpx-viewer id="gpxViewer"></gpx-viewer>
    </div>

    <div class="section">
      <h2>3. Device Messages/Log</h2>
      <div id="messages"></div>
    </div>
  </div>

  <script type="module">
    // --- Configuration ---
    const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e'; // Example: Nordic UART Service
    const UART_TX_CHARACTERISTIC_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_RX_CHARACTERISTIC_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

    // --- BLE Variables ---
    let bleDevice;
    let uartService;
    let txCharacteristic;
    let rxCharacteristic;
    let isConnected = false;
    let mtuSize = 23;

    // --- DOM Elements ---
    const connectButton = document.getElementById('connectButton');
    const listDirButton = document.getElementById('listDirButton');
    const fileListDiv = document.getElementById('fileList');
    const messagesDiv = document.getElementById('messages');
    const statusDiv = document.getElementById('status');
    const currentPathInput = document.getElementById('currentPath');

    // --- Protocol Constants ---
      const CMD_ID = {
        LIST_DIR: 0x01,
        OPEN_FILE: 0x02,
        READ_CHUNK: 0x03,
        CLOSE_FILE: 0x04,
        DELETE_FILE: 0x05,
        GET_SYS_INFO: 0x06,
        START_AGNSS_WRITE: 0x07,
        WRITE_AGNSS_CHUNK: 0x08,
        END_AGNSS_WRITE: 0x09
      };
    const ENTRY_TYPE = { FILE: 0x00, DIRECTORY: 0x01 };

    // --- Logging ---
    function log(message, isError = false) {
      const time = new Date().toLocaleTimeString();
      messagesDiv.innerHTML += `<div style="${isError ? 'color:red;' : ''}">[${time}] ${message}</div>`;
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      if (isError) console.error(`[Log] ${message}`);
      else console.log(`[Log] ${message}`);
    }

    // --- GpsDataDecoder Class (Modified for Robustness) ---
    class GpsDataDecoder {
      constructor() { }

      _readVarintS32(view, offsetObj) {
        let unsigned_val = 0;
        let shift = 0;
        let byte;
        const initialOffset = offsetObj.offset; // For error reporting

        for (let i = 0; i < 5; i++) {
          if (offsetObj.offset >= view.byteLength) {
            throw new Error(`Buffer underflow at offset ${initialOffset} while reading varint (byte ${i + 1}).`);
          }
          byte = view.getUint8(offsetObj.offset++);
          unsigned_val |= (byte & 0x7F) << shift;
          shift += 7;
          if ((byte & 0x80) === 0) {
            return (unsigned_val >>> 1) ^ -(unsigned_val & 1);
          }
        }
        throw new Error(`Varint too long or malformed at offset ${initialOffset} (exceeded 5 bytes for s32).`);
      }

      decode(arrayBuffer) {
        const points = [];
        if (!arrayBuffer || arrayBuffer.byteLength === 0) {
          log("GpsDataDecoder: Input ArrayBuffer is empty or null.", true);
          return points;
        }

        const view = new DataView(arrayBuffer);
        let offsetObj = { offset: 0 };

        let previousPoint = {
          timestamp: 0, latitude_scaled_1e5: 0,
          longitude_scaled_1e5: 0, altitude_m_scaled_1e1: 0
        };
        let isFirstPoint = true;
        let pointIndex = 0;

        while (offsetObj.offset < view.byteLength) {
          const pointStartOffset = offsetObj.offset;
          try {
            if (offsetObj.offset + 1 > view.byteLength) {
              log(`GpsDataDecoder: Buffer underflow at offset ${offsetObj.offset}: cannot read header byte for point ${pointIndex}. Remaining bytes: ${view.byteLength - offsetObj.offset}`, true);
              break; // Cannot read header, critical
            }
            const header = view.getUint8(offsetObj.offset++);
            let currentPoint = {};

            if (header === 0xFF) { // Full Block
              if (offsetObj.offset + 16 > view.byteLength) {
                throw new Error(`Buffer underflow for Full Block payload at offset ${offsetObj.offset}. Needed 16, got ${view.byteLength - offsetObj.offset}.`);
              }
              currentPoint.timestamp = view.getUint32(offsetObj.offset, true); offsetObj.offset += 4;
              currentPoint.latitude_scaled_1e5 = view.getInt32(offsetObj.offset, true); offsetObj.offset += 4;
              currentPoint.longitude_scaled_1e5 = view.getInt32(offsetObj.offset, true); offsetObj.offset += 4;
              currentPoint.altitude_m_scaled_1e1 = view.getInt32(offsetObj.offset, true); offsetObj.offset += 4;
              isFirstPoint = false;
            } else if ((header & 0x80) === 0) { // Delta Block
              if (isFirstPoint) {
                throw new Error("Invalid data: Delta Block found as the first block.");
              }
              if ((header & 0xF0) !== 0x00) { // Check reserved bits (4-6)
                throw new Error(`Invalid Delta Block header: 0x${header.toString(16)}. Reserved bits (4-6) must be 0.`);
              }
              currentPoint = { ...previousPoint };
              const flags = header & 0x0F;

              if ((flags >> 3) & 1) { currentPoint.timestamp = (currentPoint.timestamp + this._readVarintS32(view, offsetObj)) >>> 0; }
              if ((flags >> 2) & 1) { currentPoint.latitude_scaled_1e5 += this._readVarintS32(view, offsetObj); }
              if ((flags >> 1) & 1) { currentPoint.longitude_scaled_1e5 += this._readVarintS32(view, offsetObj); }
              if (flags & 1) { currentPoint.altitude_m_scaled_1e1 += this._readVarintS32(view, offsetObj); }
            } else {
              throw new Error(`Invalid block header: 0x${header.toString(16)} at offset ${pointStartOffset}.`);
            }
            points.push(currentPoint);
            previousPoint = currentPoint;

          } catch (e) {
            log(`GpsDataDecoder: Error decoding point ${pointIndex} at data offset ${pointStartOffset}: ${e.message}. Skipping point.`, true);
            // Attempt to recover by finding the next potential header. This is speculative.
            // If the error was due to a varint read, offsetObj.offset might be past the actual error point.
            // For simplicity, if an error occurred, we assume the rest of *this* point's data is unusable.
            // We already incremented offset for the header. If it fails after, the offset might be somewhere in the middle of data.
            // A truly robust recovery is complex. For now, we'll just log and hope the next byte is a valid header.
            // If the error was in _readVarintS32, offsetObj.offset would have been advanced.
            // If not, and we need to ensure we move past the failing header:
            if (offsetObj.offset === pointStartOffset + 1) {
              // Error might be in header check itself, or first varint. If offset hasn't moved much,
              // and we want to be sure we don't loop on the same byte:
              // We could try to advance offsetObj.offset further, but it's risky.
              // Safest is to break if errors are too frequent or cannot advance.
              // For now, the loop continues from the current offsetObj.offset.
            }
            if (offsetObj.offset <= pointStartOffset) { // If offset didn't advance (e.g. error before any read in block)
              log(`GpsDataDecoder: Offset did not advance after error at ${pointStartOffset}. Advancing by 1 to prevent infinite loop.`, true);
              offsetObj.offset = pointStartOffset + 1; // Force advance
            }
          }
          pointIndex++;
        }

        if (offsetObj.offset !== view.byteLength) {
          log(`GpsDataDecoder: Finished but not all bytes consumed. Offset: ${offsetObj.offset}, Length: ${view.byteLength}. May indicate trailing data or incomplete final block.`, false);
        }
        log(`GpsDataDecoder: Decoded ${points.length} points.`);
        return points;
      }
    }
    const gpsDecoder = new GpsDataDecoder();

    // --- GPX Conversion ---
    function pointsToGpxString(points, fileName) {
      if (!points || points.length === 0) {
        log("No points to convert to GPX.", true);
        return null;
      }

      let gpx = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<gpx xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"
    version="1.1" creator="MGT GPS">
  <metadata>
    <name>${fileName.replace(/\.[^/.]+$/, "")}</name>
    <time>${new Date(points[0].timestamp * 1000).toISOString()}</time>
  </metadata>
  <trk>
    <name>${fileName.replace(/\.[^/.]+$/, "")}</name>
    <trkseg>\n`;

      for (const point of points) {
        const lat = point.latitude_scaled_1e5 / 100000.0;
        const lon = point.longitude_scaled_1e5 / 100000.0;
        const ele = point.altitude_m_scaled_1e1 / 10.0;
        const time = new Date(point.timestamp * 1000).toISOString();

        // Basic validation for coordinates
        if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
          log(`Skipping invalid point in GPX: Lat ${lat}, Lon ${lon}`, true);
          continue;
        }

        gpx += `      <trkpt lat="${lat.toFixed(5)}" lon="${lon.toFixed(5)}">\n`;
        gpx += `        <ele>${ele.toFixed(1)}</ele>\n`;
        gpx += `        <time>${time}</time>\n`;
        gpx += `      </trkpt>\n`;
      }

      gpx += `    </trkseg>
  </trk>
</gpx>`;
      return gpx;
    }


    // --- UI and File Listing ---
    function clearFileList() {
      fileListDiv.innerHTML = '';
    }

    function addFileEntry(name, type, size = null, path) {
      const entryDiv = document.createElement('div');
      entryDiv.className = 'file-entry';

      const nameSpan = document.createElement('span');
      nameSpan.className = 'file-name';

      if (type === ENTRY_TYPE.DIRECTORY) {
        nameSpan.textContent = `${name} (Dir)`;
        nameSpan.className += ' dir-item-name';
        nameSpan.title = `Click to navigate to ${name}`;
        nameSpan.onclick = () => navigateToDirectory(path, name);
        entryDiv.appendChild(nameSpan);
      } else { // File
        nameSpan.textContent = `${name} (${size === null ? 'N/A' : size} bytes)`;
        nameSpan.className += ' file-item-name';
        entryDiv.appendChild(nameSpan);

        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'file-actions';

        const downloadRawButton = document.createElement('button');
        downloadRawButton.textContent = 'Download Raw';
        downloadRawButton.className = 'action-button';
        downloadRawButton.onclick = () => downloadFile(path, name, size, false);
        actionsDiv.appendChild(downloadRawButton);

        const downloadGpxButton = document.createElement('button');
        downloadGpxButton.textContent = 'Download as GPX';
        downloadGpxButton.className = 'action-button';
        const previewGpxButton = document.createElement('button');
        previewGpxButton.textContent = 'Preview GPX';
        previewGpxButton.className = 'action-button';
        downloadGpxButton.onclick = () => downloadAndConvertToGpx(path, name, size, true);
        previewGpxButton.onclick = () => downloadAndConvertToGpx(path, name, size, false);
        actionsDiv.appendChild(downloadGpxButton);
        actionsDiv.appendChild(previewGpxButton);

        // 新增 Delete 按钮
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.className = 'action-button';
        deleteButton.style.backgroundColor = '#dc3545';
        deleteButton.style.color = 'white';
        deleteButton.onclick = async () => {
          if (!confirm(`Are you sure you want to delete file: ${name}?`)) return;
          if (!confirm(`Double check: Delete file "${name}"? This cannot be undone!`)) return;
          try {
            await deleteFileViaBle(path, name);
            log(`File deleted: ${name}`);
            await listDirectory(currentPathInput.value);
          } catch (e) {
            log(`Delete failed: ${e}`, true);
          }
        };
        actionsDiv.appendChild(deleteButton);

        entryDiv.appendChild(actionsDiv);
      }
      fileListDiv.appendChild(entryDiv);
    }


    // --- Web Bluetooth Functions (Connect, Disconnect, Send) ---
    connectButton.onclick = async () => {
      if (!isConnected) {
        try {
          log('Requesting Bluetooth device...');
          bleDevice = await navigator.bluetooth.requestDevice({
            filters: [{ services: [UART_SERVICE_UUID] }],
          });
          log(`Connecting to ${bleDevice.name || `ID: ${bleDevice.id}`}...`);
          statusDiv.textContent = `Connecting to ${bleDevice.name}...`;
          const server = await bleDevice.gatt.connect();
          log('Connected to GATT Server.');
          uartService = await server.getPrimaryService(UART_SERVICE_UUID);
          log('UART Service obtained.');
          txCharacteristic = await uartService.getCharacteristic(UART_TX_CHARACTERISTIC_UUID);
          log('TX Characteristic obtained.');
          rxCharacteristic = await uartService.getCharacteristic(UART_RX_CHARACTERISTIC_UUID);
          log('RX Characteristic obtained.');
          await rxCharacteristic.startNotifications();
          rxCharacteristic.addEventListener('characteristicvaluechanged', handleRxData);
          log('Notifications started.');

          mtuSize = bleDevice.gatt.mtu || 247; // More realistic default if available
          log(`Assumed/Reported MTU: ${mtuSize} bytes.`);

          isConnected = true;
          connectButton.textContent = 'Disconnect';
          statusDiv.textContent = `Connected to ${bleDevice.name || bleDevice.id}`;
          listDirButton.disabled = false;
          bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
          await listDirectory('/');
        } catch (error) {
          log(`Error connecting: ${error.message}`, true);
          console.error("Connection Error:", error);
          statusDiv.textContent = `Error: ${error.message.substring(0, 50)}...`;
          if (bleDevice && bleDevice.gatt.connected) bleDevice.gatt.disconnect();
        }
      } else {
        if (bleDevice && bleDevice.gatt.connected) {
          log('Disconnecting...');
          bleDevice.gatt.disconnect();
        } else {
          onDisconnected();
        }
      }
    };

    function onDisconnected() {
      log('Device disconnected.');
      isConnected = false;
      connectButton.textContent = 'Connect to Device';
      statusDiv.textContent = 'Disconnected';
      listDirButton.disabled = true;
      rxCharacteristic = null; txCharacteristic = null; uartService = null; bleDevice = null;
      clearFileList();
      fileListDiv.textContent = 'Disconnected. Connect to a device to list files.';
      currentPathInput.value = "/";
    }

    async function sendBleData(data) {
      if (!txCharacteristic || !isConnected) {
        log('Error: TX Characteristic not available or not connected.', true);
        return;
      }
      try {
        // Using writeValueWithoutResponse for speed, as per common UART implementations
        await txCharacteristic.writeValueWithoutResponse(data);
        log(`Sent ${data.byteLength} bytes: ${Array.from(new Uint8Array(data)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
      } catch (error) {
        log(`Error sending data: ${error}`, true);
      }
    }

    // --- Protocol Implementation (LIST_DIR, OPEN_FILE, READ_CHUNK, CLOSE_FILE) ---
    let currentListDirPromise = null;
    let listDirEntries = [];
    let currentOpenFilePromise = null;
    let currentReadChunkPromise = null;
    let currentCloseFilePromise = null;
    let currentDeleteFilePromise = null;
      let currentGetSysInfoPromise = null;
      let currentStartAgnssWritePromise = null;
      let currentWriteAgnssChunkPromise = null;
      let currentEndAgnssWritePromise = null;

    async function listDirectory(path) {
      if (!isConnected) { log("Not connected.", true); return; }
      currentPathInput.value = path;
      clearFileList();
      if (path !== "/") { // Add ".." entry for navigation, except for root
        addFileEntry("..", ENTRY_TYPE.DIRECTORY, null, path.substring(0, path.lastIndexOf('/')) || "/");
      }
      log(`Listing directory: ${path}...`);
      listDirButton.disabled = true;
      listDirEntries = [];

      return new Promise(async (resolve, reject) => {
        currentListDirPromise = { resolve, reject, path };
        const pathBytes = new TextEncoder().encode(path);
        // Path Length field itself is 1 byte.
        // If path is "/", Path Length in payload is 1, Path is "/".
        // If path is "/logs", Path Length is 5, Path is "/logs".
        // If path is "", spec says Path Length 0 for root. But our code uses "/".
        // The spec for LIST_DIR CMD Payload: Path Length (1B), Path (ASCII, Variable)
        // "Path Length: Path field's length. If 0, then list root."
        // My previous code had: `payloadLength = 1 + pathBytes.byteLength;` and `view.setUint8(offset, pathBytes.byteLength);`
        // This seems to align with the *spirit* if not the exact wording if path="/" was sent as pathlength=1, path="/".
        // Let's stick to the spec more closely: if path is "/", send pathLength=0.
        let actualPathBytesToSend = pathBytes;
        let pathLengthField = actualPathBytesToSend.byteLength;

        if (path === "/") { // Special handling for root as per spec example (Path Length 0)
          // However, the example LIST_DIR CMD for root has PayloadLen=1, PathLength=1, Path="/".
          // This is contradictory. "Path Length: ... If 0, then list root."
          // vs "Example: CMD ID:01, PayloadLen:1, Payload: PathLength:01, Path:/"
          // Let's try to follow the spec more closely: if path is "/", send pathLength=0.
          // For now, I will keep the previous logic which sent "/" with length 1, as it was working.
          // If issues arise, this is a point to check.
          // The example in proto spec shows: Payload: Path Length (1B) = 0x01, Path (ASCII, Var) = `/` (0x2F)
          // This means payload for listing root IS: 0x01 0x2F (PathLength byte itself, then path)
          // So total PayloadLen for LIST_DIR for root is 1 (the PathLength byte) + 1 (the path byte '/'). Total 2.
          // NO, the example shows for LIST_DIR for root: Payload Len (2B) = 1, Payload: Path Length (1B) = 0.
          // This seems to mean the "Path" field is empty, and its length is 0.
          // Let's try the spec: "Path Length: Path field's length. If 0, list root"
          // So, CMD_ID (1B) | Payload Len (2B) | PathActualLength (1B) | Path (Variable)
          // If path == "/", send PathActualLength = 0. Payload will be just this 1 byte.
          // So, command is CMD_ID | 0x0001 (little endian for payload length) | 0x00 (path length is zero)
          // This seems more consistent.

          let pLengthForPayload; // Length of the "Path" string itself.
          let pathBytesForPayload;

          if (path === "/") {
            pLengthForPayload = 0;
            pathBytesForPayload = new Uint8Array(0); // No path bytes
          } else {
            pathBytesForPayload = new TextEncoder().encode(path);
            pLengthForPayload = pathBytesForPayload.byteLength;
          }

          const cmdPayloadLength = 1 + pLengthForPayload; // Path Length (1B) + actual path string
          const buffer = new ArrayBuffer(1 + 2 + cmdPayloadLength); // CMD_ID + OverallPayloadLen_uint16 + (PathLen_uint8 + Path_string)
          const view = new DataView(buffer);

          let offset = 0;
          view.setUint8(offset, CMD_ID.LIST_DIR); offset++;
          view.setUint16(offset, cmdPayloadLength, true); offset += 2; // Overall payload length
          view.setUint8(offset, pLengthForPayload); offset++;       // Length of the path string that follows
          if (pLengthForPayload > 0) {
            new Uint8Array(buffer, offset).set(pathBytesForPayload);
          }

          await sendBleData(buffer);
        }
      }).finally(() => { listDirButton.disabled = false; });
    }
    listDirButton.onclick = () => listDirectory(currentPathInput.value);


    async function openFile(filePath) {
      if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
      log(`Opening file: ${filePath}...`);
      return new Promise(async (resolve, reject) => {
        currentOpenFilePromise = { resolve, reject, filePath };
        const pathBytes = new TextEncoder().encode(filePath);
        const payloadLength = 1 + pathBytes.byteLength; // File Path Length (1B) + File Path string
        const buffer = new ArrayBuffer(1 + 2 + payloadLength);
        const view = new DataView(buffer);
        let offset = 0;
        view.setUint8(offset, CMD_ID.OPEN_FILE); offset++;
        view.setUint16(offset, payloadLength, true); offset += 2;
        view.setUint8(offset, pathBytes.byteLength); offset++;
        new Uint8Array(buffer, offset).set(pathBytes);
        await sendBleData(buffer);
      });
    }

    async function readFileChunk(offset, bytesToRead) {
      if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
      log(`Reading chunk: offset=${offset}, length=${bytesToRead}`);
      return new Promise(async (resolve, reject) => {
        currentReadChunkPromise = { resolve, reject };
        const payloadLength = 4 + 2; // Offset (4B) + Bytes to Read (2B)
        const buffer = new ArrayBuffer(1 + 2 + payloadLength);
        const view = new DataView(buffer);
        let idx = 0;
        view.setUint8(idx, CMD_ID.READ_CHUNK); idx++;
        view.setUint16(idx, payloadLength, true); idx += 2;
        view.setUint32(idx, offset, true); idx += 4;
        view.setUint16(idx, bytesToRead, true);
        await sendBleData(buffer);
      });
    }

    async function closeFile() {
      if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
      log(`Closing file...`);
      return new Promise(async (resolve, reject) => {
        currentCloseFilePromise = { resolve, reject };
        const payloadLength = 0;
        const buffer = new ArrayBuffer(1 + 2 + payloadLength);
        const view = new DataView(buffer);
        view.setUint8(0, CMD_ID.CLOSE_FILE);
        view.setUint16(1, payloadLength, true);
        await sendBleData(buffer);
      });
    }

    // --- RX Data Handler ---
    function handleRxData(event) {
      const value = event.target.value; // DataView
      const dataArray = new Uint8Array(value.buffer);
      log(`Received ${dataArray.byteLength} bytes: ${Array.from(dataArray).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);

      if (dataArray.length < 2) { log("Error: RX data too short for Payload Len.", true); return; }
      const payloadLen = value.getUint16(0, true);
      const payload = new DataView(value.buffer, 2, payloadLen);
      log(`Parsed RX Payload Len: ${payloadLen}`);

      // --- 新增：GET_SYS_INFO 响应处理 ---
      if (currentSysInfoPromise && payloadLen === SYSINFO_PAYLOAD_LEN) {
        try {
          const info = parseSysInfoPayload(payload);
          currentSysInfoPromise.resolve(info);
        } catch (e) {
          currentSysInfoPromise.reject(e);
        }
        currentSysInfoPromise = null;
        return;
      }

      if (currentListDirPromise) {
        // ... (LIST_DIR_RSP handling - ensuring it uses the current path from the promise)
        const promise = currentListDirPromise; // Capture before it's potentially nulled

        if (payloadLen === 0) {
          log("LIST_DIR_RSP: Empty payload or error for path: " + promise.path, true);
          if (promise.reject) promise.reject("Empty LIST_DIR_RSP");
          currentListDirPromise = null; return;
        }
        if (payloadLen === 1 && payload.byteLength >= 1 && payload.getUint8(0) === 0x00) {
          log(`LIST_DIR_RSP for ${promise.path}: No more entries (or empty directory). Listing complete.`);
          if (listDirEntries.length === 0) fileListDiv.innerHTML += `<div>Directory is empty or no entries found.</div>`;
          if (promise.resolve) promise.resolve(listDirEntries);
          currentListDirPromise = null; return;
        }
        if (payload.byteLength < 3) { // Min: More Flag (1) + Entry Type (1) + Name Length (1)
          log(`LIST_DIR_RSP for ${promise.path}: Payload too short (${payload.byteLength}B) for minimal entry.`, true);
          if (promise.reject) promise.reject("LIST_DIR_RSP too short");
          currentListDirPromise = null; return;
        }

        let offset = 0;
        const moreFlag = payload.getUint8(offset); offset++;
        const entryType = payload.getUint8(offset); offset++;
        const nameLength = payload.getUint8(offset); offset++;

        if (offset + nameLength > payload.byteLength) {
          log(`LIST_DIR_RSP for ${promise.path}: Name length (${nameLength}) exceeds payload bounds (${payload.byteLength - offset} available).`, true);
          if (promise.reject) promise.reject("LIST_DIR_RSP name length error");
          currentListDirPromise = null; return;
        }
        const nameBytes = new Uint8Array(payload.buffer, payload.byteOffset + offset, nameLength);
        const name = new TextDecoder().decode(nameBytes);
        offset += nameLength;
        log(`LIST_DIR_RSP: Path=${promise.path}, More=${moreFlag}, Type=${entryType}, Name=${name}`);

        let fileSize = null;
        if (entryType === ENTRY_TYPE.FILE) {
          if (offset + 4 <= payload.byteLength) {
            fileSize = payload.getUint32(offset, true);
            log(`  File Size: ${fileSize}`);
          } else { log(`LIST_DIR_RSP for ${promise.path}: File entry '${name}', but file size is missing or payload too short.`, true); }
        }
        // Construct full path for the entry. promise.path is the *directory* being listed.
        const entryFullPath = (promise.path === '/' ? '/' : promise.path + '/') + name;
        addFileEntry(name, entryType, fileSize, entryFullPath.replace(/\/\//g, '/'));
        listDirEntries.push({ name, type: entryType, size: fileSize, path: entryFullPath.replace(/\/\//g, '/') });

        if (moreFlag === 0x00) {
          log(`LIST_DIR_RSP for ${promise.path}: No more entries. Listing complete.`);
          if (promise.resolve) promise.resolve(listDirEntries);
          currentListDirPromise = null;
        } else {
          log(`LIST_DIR_RSP for ${promise.path}: More entries exist, requesting next...`);
          // Re-send LIST_DIR for the *same directory path* (promise.path)
          const pathForNext = promise.path;
          let pLengthForPayload;
          let pathBytesForPayload;
          if (pathForNext === "/") { pLengthForPayload = 0; pathBytesForPayload = new Uint8Array(0); }
          else { pathBytesForPayload = new TextEncoder().encode(pathForNext); pLengthForPayload = pathBytesForPayload.byteLength; }

          const cmdPayloadLength = 1 + pLengthForPayload;
          const buffer = new ArrayBuffer(1 + 2 + cmdPayloadLength);
          const view = new DataView(buffer);
          let o = 0;
          view.setUint8(o, CMD_ID.LIST_DIR); o++;
          view.setUint16(o, cmdPayloadLength, true); o += 2;
          view.setUint8(o, pLengthForPayload); o++;
          if (pLengthForPayload > 0) new Uint8Array(buffer, o).set(pathBytesForPayload);
          sendBleData(buffer); // The currentListDirPromise remains active for the next response
        }
      } else if (currentOpenFilePromise) {
        const promise = currentOpenFilePromise; currentOpenFilePromise = null;
        if (payloadLen === 4 && payload.byteLength === 4) {
          const fileSize = payload.getUint32(0, true);
          log(`OPEN_FILE_RSP for ${promise.filePath}: Success, File Size = ${fileSize} bytes.`);
          promise.resolve({ filePath: promise.filePath, fileSize });
        } else if (payloadLen === 0) {
          log(`OPEN_FILE_RSP for ${promise.filePath}: Failed to open file.`, true);
          promise.reject(`Failed to open file: ${promise.filePath}`);
        } else {
          log(`OPEN_FILE_RSP for ${promise.filePath}: Unexpected payload length ${payloadLen}.`, true);
          promise.reject(`OPEN_FILE_RSP unexpected payload for ${promise.filePath}`);
        }
      } else if (currentReadChunkPromise) {
        const promise = currentReadChunkPromise; currentReadChunkPromise = null;
        if (payloadLen >= 2 && payload.byteLength >= 2) {
          const actualBytesRead = payload.getUint16(0, true);
          log(`READ_CHUNK_RSP: Actual Bytes Read = ${actualBytesRead}`);
          if (actualBytesRead > 0) {
            if (payload.byteLength >= 2 + actualBytesRead) {
              const fileData = new Uint8Array(payload.buffer, payload.byteOffset + 2, actualBytesRead);
              promise.resolve({ actualBytesRead, data: fileData });
            } else {
              log("READ_CHUNK_RSP: actualBytesRead > 0 but payload too short for data.", true);
              promise.reject("READ_CHUNK_RSP: inconsistent payload for data");
            }
          } else {
            promise.resolve({ actualBytesRead: 0, data: new Uint8Array(0) });
          }
        } else {
          log("READ_CHUNK_RSP: Payload too short for 'Actual Bytes Read'.", true);
          promise.reject("READ_CHUNK_RSP: payload too short");
        }
      } else if (currentCloseFilePromise) {
        const promise = currentCloseFilePromise; currentCloseFilePromise = null;
        if (payloadLen === 0) {
          log("CLOSE_FILE_RSP: File closed successfully.");
          promise.resolve();
        } else {
          log(`CLOSE_FILE_RSP: Unexpected payload length ${payloadLen}. Assuming closed.`, true);
          promise.resolve();
        }
      } else if (currentDeleteFilePromise) {
        const promise = currentDeleteFilePromise; currentDeleteFilePromise = null;
        if (payloadLen === 0) {
          log(`DELETE_FILE_RSP for ${promise.filePath}: File deleted successfully.`);
          promise.resolve();
        } else {
          log(`DELETE_FILE_RSP for ${promise.filePath}: Unexpected payload length ${payloadLen}.`, true);
          promise.reject('Delete failed or not permitted');
        }
      } else if (currentGetSysInfoPromise) {
        const promise = currentGetSysInfoPromise; currentGetSysInfoPromise = null;
        if (payloadLen === 50 && payload.byteLength === 50) {
          log("GET_SYS_INFO_RSP: Received system info data.");
          const sysInfo = parseSysInfoFromBuffer(payload);
          promise.resolve(sysInfo);
        } else {
          log(`GET_SYS_INFO_RSP: Unexpected payload length ${payloadLen}, expected 50.`, true);
          promise.reject('GET_SYS_INFO_RSP: invalid payload length');
        }
      } else if (currentStartAgnssWritePromise) {
        const promise = currentStartAgnssWritePromise; currentStartAgnssWritePromise = null;
        if (payloadLen === 0) {
          log("START_AGNSS_WRITE_RSP: Device ready to receive AGNSS data.");
          promise.resolve();
        } else {
          log(`START_AGNSS_WRITE_RSP: Unexpected payload length ${payloadLen}.`, true);
          promise.reject(new Error('START_AGNSS_WRITE failed'));
        }
      } else if (currentWriteAgnssChunkPromise) {
        const promise = currentWriteAgnssChunkPromise; currentWriteAgnssChunkPromise = null;
        if (payloadLen === 0) {
          log("WRITE_AGNSS_CHUNK_RSP: Chunk written successfully.");
          promise.resolve();
        } else {
          log(`WRITE_AGNSS_CHUNK_RSP: Unexpected payload length ${payloadLen}.`, true);
          promise.reject(new Error('WRITE_AGNSS_CHUNK failed'));
        }
      } else if (currentEndAgnssWritePromise) {
        const promise = currentEndAgnssWritePromise; currentEndAgnssWritePromise = null;
        if (payloadLen === 0) {
          log("END_AGNSS_WRITE_RSP: AGNSS data transfer completed successfully.");
          promise.resolve();
        } else {
          log(`END_AGNSS_WRITE_RSP: Unexpected payload length ${payloadLen}.`, true);
          promise.reject(new Error('END_AGNSS_WRITE failed'));
        }
      }
      else {
        log("Received data, but no matching command promise was found. Ignoring.", true);
      }
    }

    // --- 文件删除协议实现 ---
    async function deleteFileViaBle(filePath, fileName) {
      if (!isConnected) throw new Error('Not connected');
      log(`Sending DELETE_FILE for: ${filePath}`);
      return new Promise(async (resolve, reject) => {
        currentDeleteFilePromise = { resolve, reject, filePath, fileName };
        const pathBytes = new TextEncoder().encode(filePath);
        const payloadLength = 1 + pathBytes.byteLength;
        const buffer = new ArrayBuffer(1 + 2 + payloadLength);
        const view = new DataView(buffer);
        let offset = 0;
        view.setUint8(offset, CMD_ID.DELETE_FILE); offset++;
        view.setUint16(offset, payloadLength, true); offset += 2;
        view.setUint8(offset, pathBytes.byteLength); offset++;
        new Uint8Array(buffer, offset).set(pathBytes);
        await sendBleData(buffer);
        // 超时保护
        setTimeout(() => {
          if (currentDeleteFilePromise) {
            currentDeleteFilePromise = null;
            reject('Timeout waiting for delete response');
          }
        }, 3000);
      });
    }

    // --- File Download Logic ---
    async function downloadFileCore(filePath, fileName, expectedSize) {
      // This function will handle the BLE communication to get the raw ArrayBuffer
      if (!isConnected) {
        log("Cannot download: Not connected.", true);
        throw new Error("Not connected");
      }
      log(`Starting raw download for: ${filePath} (Size: ${expectedSize} bytes)`);
      listDirButton.disabled = true;

      try {
        const { fileSize: openedFileSize } = await openFile(filePath);
        let effectiveFileSize = openedFileSize;
        if (expectedSize !== null && openedFileSize !== expectedSize) {
          log(`Warning: Opened file size (${openedFileSize}) differs from listed size (${expectedSize}). Using opened size.`);
        } else if (expectedSize !== null) {
          effectiveFileSize = expectedSize; // Prefer listed size if consistent or only one available
        }
        log(`File opened: ${filePath}, Effective Size: ${effectiveFileSize} bytes.`);

        let receivedBytes = 0;
        const fileChunks = [];
        // Max data in READ_CHUNK_RSP payload = MTU - ATT_HDR(3) - UART_RX_HDR(0 for this level) - Proto_RSP_HDR(PayloadLen=2 + ActualBytesRead=2)
        // So, max data = MTU - 3 - 4 = MTU - 7.
        // Let's be slightly more conservative: mtuSize - 10 or a fixed like 128.
        const CHUNK_SIZE_TO_REQUEST = Math.max(16, Math.min(128, mtuSize - 10));
        log(`Requesting chunks of size: ${CHUNK_SIZE_TO_REQUEST}`);

        while (receivedBytes < effectiveFileSize) {
          const bytesToRead = Math.min(CHUNK_SIZE_TO_REQUEST, effectiveFileSize - receivedBytes);
          if (bytesToRead <= 0) break;

          statusDiv.textContent = `Downloading ${fileName}: ${Math.round((receivedBytes / effectiveFileSize) * 100)}%`;
          const { actualBytesRead, data } = await readFileChunk(receivedBytes, bytesToRead);

          if (actualBytesRead > 0 && data) {
            fileChunks.push(data);
            receivedBytes += actualBytesRead;
            log(`Downloaded ${receivedBytes} / ${effectiveFileSize} bytes...`);
          } else {
            log("Reached EOF or read error (actualBytesRead is 0 or no data).");
            if (receivedBytes < effectiveFileSize) {
              log(`Warning: Download ended prematurely. Expected ${effectiveFileSize}, got ${receivedBytes}.`, true);
            }
            break;
          }
        }
        statusDiv.textContent = `Downloaded ${fileName}: ${Math.round((receivedBytes / effectiveFileSize) * 100)}% Complete.`;

        if (fileChunks.length > 0) {
          const totalReceived = fileChunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);
          if (totalReceived !== receivedBytes) { // Sanity check
            log(`Internal Mismatch: receivedBytes=${receivedBytes}, chunksTotal=${totalReceived}`, true);
          }
          // Combine chunks into a single ArrayBuffer
          const finalBuffer = new Uint8Array(totalReceived);
          let currentOffset = 0;
          for (const chunk of fileChunks) {
            finalBuffer.set(new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength), currentOffset);
            currentOffset += chunk.byteLength;
          }
          return finalBuffer.buffer; // Return the ArrayBuffer
        } else if (effectiveFileSize === 0 && receivedBytes === 0) {
          log("Downloaded an empty file successfully.");
          return new ArrayBuffer(0);
        }
        else {
          throw new Error(`Download failed or file empty. Received ${receivedBytes} of ${effectiveFileSize} bytes.`);
        }

      } catch (error) {
        log(`Error during raw download of ${filePath}: ${error}`, true);
        statusDiv.textContent = `Error downloading ${filePath}`;
        throw error; // Re-throw to be caught by caller
      } finally {
        try {
          await closeFile();
          log("File closed after raw download attempt for " + filePath);
        } catch (closeError) {
          log(`Error closing file after raw download of ${filePath}: ${closeError}`, true);
        }
        listDirButton.disabled = false;
        if (isConnected) statusDiv.textContent = `Connected to ${bleDevice.name || bleDevice.id}`;
      }
    }

    async function downloadFile(filePath, fileName, expectedSize) {
      try {
        const rawFileBuffer = await downloadFileCore(filePath, fileName, expectedSize);
        if (rawFileBuffer) {
          const fileBlob = new Blob([rawFileBuffer]);
          const downloadUrl = URL.createObjectURL(fileBlob);
          const a = document.createElement('a');
          a.href = downloadUrl;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          URL.revokeObjectURL(downloadUrl);
          a.remove();
          log(`Raw file "${fileName}" saved.`);
          statusDiv.textContent = `Saved ${fileName}`;
        }
      } catch (error) {
        log(`Overall download process for ${fileName} failed: ${error}`, true);
      }
    }

    // --- GPX 预览集成 gpx-viewer ---
    const gpxViewer = document.getElementById('gpxViewer');

    async function downloadAndConvertToGpx(filePath, fileName, expectedSize, download) {
      try {
        statusDiv.textContent = `Downloading ${fileName} for GPX conversion...`;
        const rawFileBuffer = await downloadFileCore(filePath, fileName, expectedSize);
        if (!rawFileBuffer) {
          log(`GPX Conversion: Failed to download raw data for ${fileName}.`, true);
          statusDiv.textContent = `GPX conversion failed for ${fileName}.`;
          return;
        }
        // 解码为轨迹点
        const points = gpsDecoder.decode(rawFileBuffer);
        if (!points || points.length === 0) {
          log(`GPX Conversion: No valid points decoded for ${fileName}.`, true);
          statusDiv.textContent = `No valid points for GPX conversion in ${fileName}.`;
          return;
        }
        // 转为GPX字符串
        const gpxString = pointsToGpxString(points, fileName);
        if (!gpxString) {
          log(`GPX Conversion: Failed to convert points to GPX for ${fileName}.`, true);
          statusDiv.textContent = `GPX conversion failed for ${fileName}.`;
          return;
        }
        if (download) {
          // 下载 GPX
          const blob = new Blob([gpxString], { type: 'application/gpx+xml' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = fileName.replace(/\.[^/.]+$/, '') + '.gpx';
          document.body.appendChild(a);
          a.click();
          setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
          log(`GPX file downloaded: ${fileName}`);
        } else {
          // 预览 GPX：调用 gpx-viewer
          if (gpxViewer && typeof gpxViewer.setGpx === 'function') {
            gpxViewer.setGpx(gpxString);
            log(`GPX loaded in viewer: ${fileName}`);
          } else {
            log('gpx-viewer element not found or setGpx not available.', true);
          }
        }
      } catch (e) {
        log(`GPX conversion/preview failed: ${e}`, true);
        statusDiv.textContent = `GPX conversion/preview failed: ${e}`;
      }
    }


    // --- Navigation ---
    function navigateToDirectory(currentFullPath, dirNameClicked) {
      let newPath;
      if (dirNameClicked === "..") {
        if (currentFullPath === "/" || !currentFullPath.includes('/')) {
          newPath = "/";
        } else {
          // currentFullPath is path of ".." entry, which is the parent dir.
          // So if currentFullPath = /foo/bar (meaning .. is in /foo/bar, pointing to /foo)
          // then newPath should be /foo.
          // The `path` passed to addFileEntry for ".." is already the parent path.
          newPath = currentFullPath; // The path for ".." is its destination
        }
      } else {
        // dirNameClicked is a directory name, currentFullPath is its path.
        newPath = currentFullPath;
      }
      newPath = newPath.replace(/\/\//g, '/'); // Sanitize
      if (newPath !== "/" && newPath.endsWith("/")) newPath = newPath.slice(0, -1); // Remove trailing slash unless root
      if (newPath === "") newPath = "/";


      currentPathInput.value = newPath;
      listDirectory(newPath);
    }

    // Initial setup
    log("Page loaded. Ready to connect.");
    if (!navigator.bluetooth) {
      log("Web Bluetooth API is not available in this browser. Please use compatible browser (e.g., Chrome, Edge).", true);
      connectButton.disabled = true;
      statusDiv.textContent = "Web Bluetooth not supported.";
    }

    // --- 新增：GET_SYS_INFO 相关 ---
    // CMD_ID 0x06
    let currentSysInfoPromise = null;

    async function getSysInfoViaBle() {
      if (!isConnected) {
        log('未连接设备，无法查询系统信息。', true);
        return;
      }
      try {
        const CMD_ID_SYSINFO = 0x06;
        const payloadLength = 0;
        const buffer = new ArrayBuffer(1 + 2);
        const view = new DataView(buffer);
        view.setUint8(0, CMD_ID_SYSINFO);
        view.setUint16(1, payloadLength, true);
        return await new Promise(async (resolve, reject) => {
          currentSysInfoPromise = { resolve, reject };
          await sendBleData(buffer);
        });
      } catch (e) {
        log('查询系统信息失败: ' + e, true);
      }
    }

    const SYSINFO_PAYLOAD_LEN = 50;
    function parseSysInfoPayload(payload) {
      let offset = 0;
      function getFloat32() { const v = payload.getFloat32(offset, true); offset += 4; return v; }
      function getFloat64() { const v = payload.getFloat64(offset, true); offset += 8; return v; }
      function getUint32() { const v = payload.getUint32(offset, true); offset += 4; return v; }
      function getUint16() { const v = payload.getUint16(offset, true); offset += 2; return v; }
      function getUint8() { const v = payload.getUint8(offset); offset += 1; return v; }
      return {
        latitude: getFloat64(),
        longitude: getFloat64(),
        altitude: getFloat32(),
        satellites: getUint32(),
        hdop: getFloat32(),
        speed: getFloat32(),
        course: getFloat32(),
        year: getUint16(),
        month: getUint8(),
        day: getUint8(),
        hour: getUint8(),
        minute: getUint8(),
        second: getUint8(),
        locationValid: getUint8(),
        dateTimeValid: getUint8(),
        batteryVoltage: getFloat32(),
        gpsState: getUint8(),
      };
    }

    // --- 优化 sysinfo 卡片刷新逻辑 ---
    function updateSysInfoCard(info) {
      const gpsStateMap = ['初始化中', "搜索中", "已关机", "已定位", "分析静止状态", "传输AGNSS数据中"]
      const yesNo = v => v ? '是' : '否';
      const set = (id, val) => { const el = document.getElementById(id); if (el) el.innerText = val; };
      if (!info) {
        [
          'latitude', 'longitude', 'altitude', 'satellites', 'hdop', 'speed', 'course',
          'date', 'time', 'locationValid', 'dateTimeValid', 'batteryVoltage', 'gpsState'
        ].forEach(id => set('sysinfo-' + id, '-'));
        return;
      }
      set('sysinfo-latitude', info.latitude.toFixed(7) + '°');
      set('sysinfo-longitude', info.longitude.toFixed(7) + '°');
      set('sysinfo-altitude', info.altitude.toFixed(1) + 'm');
      set('sysinfo-satellites', info.satellites);
      set('sysinfo-hdop', info.hdop.toFixed(2));
      set('sysinfo-speed', info.speed.toFixed(2) + 'km/h');
      set('sysinfo-course', info.course.toFixed(2) + '°');
      set('sysinfo-date', `${info.year}-${String(info.month).padStart(2, '0')}-${String(info.day).padStart(2, '0')}`);
      set('sysinfo-time', `${String(info.hour).padStart(2, '0')}:${String(info.minute).padStart(2, '0')}:${String(info.second).padStart(2, '0')}`);
      set('sysinfo-locationValid', yesNo(info.locationValid));
      set('sysinfo-dateTimeValid', yesNo(info.dateTimeValid));
      set('sysinfo-batteryVoltage', info.batteryVoltage.toFixed(2) + 'V');
      set('sysinfo-gpsState', gpsStateMap[info.gpsState] || info.gpsState);
    }

    // --- 事件绑定 ---
    document.getElementById('sysInfoButton').onclick = async function () {
      const btn = this;
      const errorDiv = document.getElementById('sysinfo-error');
      btn.disabled = true;
      btn.textContent = '查询中...';
      errorDiv.innerText = '';
      try {
        const info = await getSysInfoViaBle();
        if (info) {
          updateSysInfoCard(info);
        } else {
          updateSysInfoCard(null);
          errorDiv.innerText = '未获取到设备信息。';
        }
      } catch (e) {
        updateSysInfoCard(null);
        errorDiv.innerText = '查询失败: ' + e;
      } finally {
        btn.disabled = false;
        btn.textContent = 'Query Status';
      }
    };

  // --- AGNSS 按钮事件绑定 ---
  document.getElementById('agnssButton').onclick = async function () {
    await downloadAndSendAgnssData();
  };

  // --- AGNSS Protocol Functions ---
  async function startAgnssWrite() {
    if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
    log(`Starting AGNSS write...`);
    return new Promise(async (resolve, reject) => {
      const timeoutId = setTimeout(() => {
        if (currentStartAgnssWritePromise === promiseObj) {
          currentStartAgnssWritePromise = null;
          reject(new Error('Timeout waiting for START_AGNSS_WRITE response'));
        }
      }, 10000);

      const promiseObj = {
        resolve: (result) => {
          clearTimeout(timeoutId);
          resolve(result);
        },
        reject: (error) => {
          clearTimeout(timeoutId);
          reject(error);
        }
      };

      currentStartAgnssWritePromise = promiseObj;

      const payloadLength = 0;
      const buffer = new ArrayBuffer(1 + 2 + payloadLength);
      const view = new DataView(buffer);
      view.setUint8(0, CMD_ID.START_AGNSS_WRITE);
      view.setUint16(1, payloadLength, true);
      await sendBleData(buffer);
    });
  }

  async function writeAgnssChunk(chunkData) {
    if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
    const chunkSize = chunkData.byteLength;
    log(`Writing AGNSS chunk of ${chunkSize} bytes...`);
    return new Promise(async (resolve, reject) => {
      const timeoutId = setTimeout(() => {
        if (currentWriteAgnssChunkPromise === promiseObj) {
          currentWriteAgnssChunkPromise = null;
          reject(new Error('Timeout waiting for WRITE_AGNSS_CHUNK response'));
        }
      }, 10000); // 增加超时时间到10秒

      const promiseObj = {
        resolve: (result) => {
          clearTimeout(timeoutId);
          resolve(result);
        },
        reject: (error) => {
          clearTimeout(timeoutId);
          reject(error);
        }
      };

      currentWriteAgnssChunkPromise = promiseObj;

      const payloadLength = 2 + chunkSize; // Chunk Size (2B) + Data
      const buffer = new ArrayBuffer(1 + 2 + payloadLength);
      const view = new DataView(buffer);
      let offset = 0;

      view.setUint8(offset, CMD_ID.WRITE_AGNSS_CHUNK); offset++;
      view.setUint16(offset, payloadLength, true); offset += 2;
      view.setUint16(offset, chunkSize, true); offset += 2;
      new Uint8Array(buffer, offset).set(new Uint8Array(chunkData));

      await sendBleData(buffer);
    });
  }

  async function endAgnssWrite() {
    if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
    log(`Ending AGNSS write...`);
    return new Promise(async (resolve, reject) => {
      const timeoutId = setTimeout(() => {
        if (currentEndAgnssWritePromise === promiseObj) {
          currentEndAgnssWritePromise = null;
          reject(new Error('Timeout waiting for END_AGNSS_WRITE response'));
        }
      }, 10000);

      const promiseObj = {
        resolve: (result) => {
          clearTimeout(timeoutId);
          resolve(result);
        },
        reject: (error) => {
          clearTimeout(timeoutId);
          reject(error);
        }
      };

      currentEndAgnssWritePromise = promiseObj;

      const payloadLength = 0;
      const buffer = new ArrayBuffer(1 + 2 + payloadLength);
      const view = new DataView(buffer);
      view.setUint8(0, CMD_ID.END_AGNSS_WRITE);
      view.setUint16(1, payloadLength, true);
      await sendBleData(buffer);
    });
  }

  // --- AGNSS Data Transfer Function ---
  async function downloadAndSendAgnssData() {
    const agnssButton = document.getElementById('agnssButton');
    const agnssStatus = document.getElementById('agnssStatus');

    if (!isConnected) {
      log("Cannot send AGNSS data: Not connected.", true);
      return;
    }

    try {
      // 禁用按钮并显示状态
      agnssButton.disabled = true;
      agnssButton.textContent = 'Processing...';
      agnssStatus.style.display = 'block';
      agnssStatus.textContent = 'AGNSS Status: Downloading data...';

      log("Starting AGNSS data download and processing...");

      // 调用 AGNSS 数据处理函数
      const result = await window.processAGNSSData();

      if (!result || !Array.isArray(result) || result.length === 0) {
        throw new Error("No AGNSS data received or invalid format");
      }

      log(`Received ${result.length} AGNSS data chunks`);
      agnssStatus.textContent = `AGNSS Status: Downloaded ${result.length} chunks, starting transfer...`;

      // 开始 AGNSS 写入
      await startAgnssWrite();
      log("AGNSS write session started successfully");

      // 计算最大块大小（考虑 MTU 限制）
      // Max chunk size = MTU - ATT_HDR(3) - CMD_ID(1) - Payload_Len(2) - Chunk_Size(2)
      const maxChunkSize = Math.max(16, Math.min(128, mtuSize - 8));
      log(`Using max chunk size: ${maxChunkSize} bytes`);

      let totalChunks = 0;
      let totalBytes = 0;

      // 逐个发送 AGNSS 数据块
      for (let i = 0; i < result.length; i++) {
        const agnssData = result[i];
        if (!(agnssData instanceof Uint8Array)) {
          log(`Warning: AGNSS data chunk ${i} is not Uint8Array, skipping`, true);
          continue;
        }

        agnssStatus.textContent = `AGNSS Status: Sending chunk ${i + 1}/${result.length}...`;

        // 如果数据块太大，需要分片发送
        let offset = 0;
        while (offset < agnssData.length) {
          const chunkSize = Math.min(maxChunkSize, agnssData.length - offset);
          const chunk = agnssData.slice(offset, offset + chunkSize);

          await writeAgnssChunk(chunk);
          log(`Sent AGNSS chunk ${totalChunks + 1}: ${chunkSize} bytes`);

          offset += chunkSize;
          totalChunks++;
          totalBytes += chunkSize;

          // 增加延迟以避免过载设备和竞态条件
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      }

      // 结束 AGNSS 写入
      await endAgnssWrite();

      log(`AGNSS data transfer completed successfully: ${totalChunks} chunks, ${totalBytes} bytes total`);
      agnssStatus.textContent = `AGNSS Status: Transfer completed (${totalChunks} chunks, ${totalBytes} bytes)`;

    } catch (error) {
      log(`AGNSS data transfer failed: ${error}`, true);
      agnssStatus.textContent = `AGNSS Status: Transfer failed - ${error.message}`;
    } finally {
      // 恢复按钮状态
      agnssButton.disabled = false;
      agnssButton.textContent = 'Download & Send AGNSS';
      setTimeout(() => {
        agnssStatus.style.display = 'none';
      }, 5000);
    }
  }

  // ...existing code...
  </script>
  <script src="agnss_data_fetcher.js"></script>
  <script src="casic_agnss_processor.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@5.6.0/dist/maplibre-gl.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gpx_viewer@1.0.1/lib/gpx-viewer.umd.js"></script>
</body>

</html>
