<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Web Bluetooth File Explorer with GPX Conversion</title>
  <link href="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.js" defer></script>
  <style>
    #map {
      height: 500px;
      width: 100%;
    }

    .controls {
      background: rgba(255, 255, 255, 0.8);
      padding: 10px 20px;
      border-radius: 5px;
      z-index: 1;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .controls label {
      font-family: sans-serif;
      font-size: 14px;
    }

    #timeslider {
      width: 300px;
    }

    #timestamp-display {
      font-family: monospace;
      font-size: 13px;
      min-width: 180px;
      /* 保证足够宽度显示时间 */
    }
  </style>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background-color: #f4f4f4;
      color: #333;
    }

    .container {
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }

    h1,
    h2 {
      color: #0056b3;
    }

    button,
    .action-button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 0.9em;
      margin: 5px 2px;
      text-decoration: none;
      display: inline-block;
    }

    button:hover,
    .action-button:hover {
      background-color: #0056b3;
    }

    button:disabled,
    .action-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    #fileList,
    #messages {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #e9ecef;
      min-height: 100px;
      max-height: 300px;
      overflow-y: auto;
    }

    #fileList .file-entry {
      padding: 8px 5px;
      border-bottom: 1px solid #ccc;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #fileList .file-entry:last-child {
      border-bottom: none;
    }

    #fileList .file-name {
      flex-grow: 1;
    }

    #fileList .file-actions button,
    #fileList .file-actions .action-button {
      font-size: 0.8em;
      padding: 5px 8px;
    }

    .file-item-name {
      color: #007bff;
    }

    .dir-item-name {
      color: #28a745;
      cursor: pointer;
    }

    .dir-item-name:hover {
      text-decoration: underline;
    }

    .status {
      margin-top: 10px;
      font-style: italic;
    }

    .section {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    input[type="text"] {
      width: calc(100% - 22px);
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Web Bluetooth File Explorer & GPX Converter</h1>

    <div class="section">
      <h2>1. Connection</h2>
      <button id="connectButton">Connect to Device</button>
      <div id="status" class="status">Disconnected</div>
    </div>

    <div class="section">
      <h2>2. File System</h2>
      <label for="currentPath">Current Path:</label>
      <input type="text" id="currentPath" value="/" readonly>
      <button id="listDirButton" disabled>List Directory</button>
      <div id="fileList">No files listed.</div>
    </div>

    <div class="section">
      <div id="map"></div>
      <div class="controls">
        <label for="timeslider">轨迹进度:</label>
        <input type="range" id="timeslider" min="0" value="0" step="1" />
        <div id="timestamp-display">未加载数据</div>
      </div>
    </div>

    <div class="section">
      <h2>3. Device Messages/Log</h2>
      <div id="messages"></div>
    </div>
  </div>

  <script type="module">
    // --- Configuration ---
    const UART_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e'; // Example: Nordic UART Service
    const UART_TX_CHARACTERISTIC_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const UART_RX_CHARACTERISTIC_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';

    // --- BLE Variables ---
    let bleDevice;
    let uartService;
    let txCharacteristic;
    let rxCharacteristic;
    let isConnected = false;
    let mtuSize = 23;

    // --- DOM Elements ---
    const connectButton = document.getElementById('connectButton');
    const listDirButton = document.getElementById('listDirButton');
    const fileListDiv = document.getElementById('fileList');
    const messagesDiv = document.getElementById('messages');
    const statusDiv = document.getElementById('status');
    const currentPathInput = document.getElementById('currentPath');

    // --- Protocol Constants ---
    const CMD_ID = { LIST_DIR: 0x01, OPEN_FILE: 0x02, READ_CHUNK: 0x03, CLOSE_FILE: 0x04 };
    const ENTRY_TYPE = { FILE: 0x00, DIRECTORY: 0x01 };

    // --- Logging ---
    function log(message, isError = false) {
      const time = new Date().toLocaleTimeString();
      messagesDiv.innerHTML += `<div style="${isError ? 'color:red;' : ''}">[${time}] ${message}</div>`;
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
      if (isError) console.error(`[Log] ${message}`);
      else console.log(`[Log] ${message}`);
    }

    // --- GpsDataDecoder Class (Modified for Robustness) ---
    class GpsDataDecoder {
      constructor() { }

      _readVarintS32(view, offsetObj) {
        let unsigned_val = 0;
        let shift = 0;
        let byte;
        const initialOffset = offsetObj.offset; // For error reporting

        for (let i = 0; i < 5; i++) {
          if (offsetObj.offset >= view.byteLength) {
            throw new Error(`Buffer underflow at offset ${initialOffset} while reading varint (byte ${i + 1}).`);
          }
          byte = view.getUint8(offsetObj.offset++);
          unsigned_val |= (byte & 0x7F) << shift;
          shift += 7;
          if ((byte & 0x80) === 0) {
            return (unsigned_val >>> 1) ^ -(unsigned_val & 1);
          }
        }
        throw new Error(`Varint too long or malformed at offset ${initialOffset} (exceeded 5 bytes for s32).`);
      }

      decode(arrayBuffer) {
        const points = [];
        if (!arrayBuffer || arrayBuffer.byteLength === 0) {
          log("GpsDataDecoder: Input ArrayBuffer is empty or null.", true);
          return points;
        }

        const view = new DataView(arrayBuffer);
        let offsetObj = { offset: 0 };

        let previousPoint = {
          timestamp: 0, latitude_scaled_1e5: 0,
          longitude_scaled_1e5: 0, altitude_m_scaled_1e1: 0
        };
        let isFirstPoint = true;
        let pointIndex = 0;

        while (offsetObj.offset < view.byteLength) {
          const pointStartOffset = offsetObj.offset;
          try {
            if (offsetObj.offset + 1 > view.byteLength) {
              log(`GpsDataDecoder: Buffer underflow at offset ${offsetObj.offset}: cannot read header byte for point ${pointIndex}. Remaining bytes: ${view.byteLength - offsetObj.offset}`, true);
              break; // Cannot read header, critical
            }
            const header = view.getUint8(offsetObj.offset++);
            let currentPoint = {};

            if (header === 0xFF) { // Full Block
              if (offsetObj.offset + 16 > view.byteLength) {
                throw new Error(`Buffer underflow for Full Block payload at offset ${offsetObj.offset}. Needed 16, got ${view.byteLength - offsetObj.offset}.`);
              }
              currentPoint.timestamp = view.getUint32(offsetObj.offset, true); offsetObj.offset += 4;
              currentPoint.latitude_scaled_1e5 = view.getInt32(offsetObj.offset, true); offsetObj.offset += 4;
              currentPoint.longitude_scaled_1e5 = view.getInt32(offsetObj.offset, true); offsetObj.offset += 4;
              currentPoint.altitude_m_scaled_1e1 = view.getInt32(offsetObj.offset, true); offsetObj.offset += 4;
              isFirstPoint = false;
            } else if ((header & 0x80) === 0) { // Delta Block
              if (isFirstPoint) {
                throw new Error("Invalid data: Delta Block found as the first block.");
              }
              if ((header & 0xF0) !== 0x00) { // Check reserved bits (4-6)
                throw new Error(`Invalid Delta Block header: 0x${header.toString(16)}. Reserved bits (4-6) must be 0.`);
              }
              currentPoint = { ...previousPoint };
              const flags = header & 0x0F;

              if ((flags >> 3) & 1) { currentPoint.timestamp = (currentPoint.timestamp + this._readVarintS32(view, offsetObj)) >>> 0; }
              if ((flags >> 2) & 1) { currentPoint.latitude_scaled_1e5 += this._readVarintS32(view, offsetObj); }
              if ((flags >> 1) & 1) { currentPoint.longitude_scaled_1e5 += this._readVarintS32(view, offsetObj); }
              if (flags & 1) { currentPoint.altitude_m_scaled_1e1 += this._readVarintS32(view, offsetObj); }
            } else {
              throw new Error(`Invalid block header: 0x${header.toString(16)} at offset ${pointStartOffset}.`);
            }
            points.push(currentPoint);
            previousPoint = currentPoint;

          } catch (e) {
            log(`GpsDataDecoder: Error decoding point ${pointIndex} at data offset ${pointStartOffset}: ${e.message}. Skipping point.`, true);
            // Attempt to recover by finding the next potential header. This is speculative.
            // If the error was due to a varint read, offsetObj.offset might be past the actual error point.
            // For simplicity, if an error occurred, we assume the rest of *this* point's data is unusable.
            // We already incremented offset for the header. If it fails after, the offset might be somewhere in the middle of data.
            // A truly robust recovery is complex. For now, we'll just log and hope the next byte is a valid header.
            // If the error was in _readVarintS32, offsetObj.offset would have been advanced.
            // If not, and we need to ensure we move past the failing header:
            if (offsetObj.offset === pointStartOffset + 1) {
              // Error might be in header check itself, or first varint. If offset hasn't moved much,
              // and we want to be sure we don't loop on the same byte:
              // We could try to advance offsetObj.offset further, but it's risky.
              // Safest is to break if errors are too frequent or cannot advance.
              // For now, the loop continues from the current offsetObj.offset.
            }
            if (offsetObj.offset <= pointStartOffset) { // If offset didn't advance (e.g. error before any read in block)
              log(`GpsDataDecoder: Offset did not advance after error at ${pointStartOffset}. Advancing by 1 to prevent infinite loop.`, true);
              offsetObj.offset = pointStartOffset + 1; // Force advance
            }
          }
          pointIndex++;
        }

        if (offsetObj.offset !== view.byteLength) {
          log(`GpsDataDecoder: Finished but not all bytes consumed. Offset: ${offsetObj.offset}, Length: ${view.byteLength}. May indicate trailing data or incomplete final block.`, false);
        }
        log(`GpsDataDecoder: Decoded ${points.length} points.`);
        return points;
      }
    }
    const gpsDecoder = new GpsDataDecoder();

    // --- GPX Conversion ---
    function pointsToGpxString(points, fileName) {
      if (!points || points.length === 0) {
        log("No points to convert to GPX.", true);
        return null;
      }

      let gpx = `<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<gpx xmlns="http://www.topografix.com/GPX/1/1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd"
    version="1.1" creator="MGT GPS">
  <metadata>
    <name>${fileName.replace(/\.[^/.]+$/, "")}</name>
    <time>${new Date(points[0].timestamp * 1000).toISOString()}</time>
  </metadata>
  <trk>
    <name>${fileName.replace(/\.[^/.]+$/, "")}</name>
    <trkseg>\n`;

      for (const point of points) {
        const lat = point.latitude_scaled_1e5 / 100000.0;
        const lon = point.longitude_scaled_1e5 / 100000.0;
        const ele = point.altitude_m_scaled_1e1 / 10.0;
        const time = new Date(point.timestamp * 1000).toISOString();

        // Basic validation for coordinates
        if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
          log(`Skipping invalid point in GPX: Lat ${lat}, Lon ${lon}`, true);
          continue;
        }

        gpx += `      <trkpt lat="${lat.toFixed(5)}" lon="${lon.toFixed(5)}">\n`;
        gpx += `        <ele>${ele.toFixed(1)}</ele>\n`;
        gpx += `        <time>${time}</time>\n`;
        gpx += `      </trkpt>\n`;
      }

      gpx += `    </trkseg>
  </trk>
</gpx>`;
      return gpx;
    }


    // --- UI and File Listing ---
    function clearFileList() {
      fileListDiv.innerHTML = '';
    }

    function addFileEntry(name, type, size = null, path) {
      const entryDiv = document.createElement('div');
      entryDiv.className = 'file-entry';

      const nameSpan = document.createElement('span');
      nameSpan.className = 'file-name';

      if (type === ENTRY_TYPE.DIRECTORY) {
        nameSpan.textContent = `${name} (Dir)`;
        nameSpan.className += ' dir-item-name';
        nameSpan.title = `Click to navigate to ${name}`;
        nameSpan.onclick = () => navigateToDirectory(path, name);
        entryDiv.appendChild(nameSpan);
      } else { // File
        nameSpan.textContent = `${name} (${size === null ? 'N/A' : size} bytes)`;
        nameSpan.className += ' file-item-name';
        entryDiv.appendChild(nameSpan);

        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'file-actions';

        const downloadRawButton = document.createElement('button');
        downloadRawButton.textContent = 'Download Raw';
        downloadRawButton.className = 'action-button';
        downloadRawButton.onclick = () => downloadFile(path, name, size, false);
        actionsDiv.appendChild(downloadRawButton);

        const downloadGpxButton = document.createElement('button');
        downloadGpxButton.textContent = 'Download as GPX';
        downloadGpxButton.className = 'action-button';
        const previewGpxButton = document.createElement('button');
        previewGpxButton.textContent = 'Preview GPX';
        previewGpxButton.className = 'action-button';
        // Assuming any file could be GPX data, enable for all.
        // Could check extension like: name.toLowerCase().endsWith('.dat')
        downloadGpxButton.onclick = () => downloadAndConvertToGpx(path, name, size, true);
        previewGpxButton.onclick = () => downloadAndConvertToGpx(path, name, size, false);
        actionsDiv.appendChild(downloadGpxButton);
        actionsDiv.appendChild(previewGpxButton);
        entryDiv.appendChild(actionsDiv);
      }
      fileListDiv.appendChild(entryDiv);
    }


    // --- Web Bluetooth Functions (Connect, Disconnect, Send) ---
    connectButton.onclick = async () => {
      if (!isConnected) {
        try {
          log('Requesting Bluetooth device...');
          bleDevice = await navigator.bluetooth.requestDevice({
            filters: [{ services: [UART_SERVICE_UUID] }],
          });
          log(`Connecting to ${bleDevice.name || `ID: ${bleDevice.id}`}...`);
          statusDiv.textContent = `Connecting to ${bleDevice.name}...`;
          const server = await bleDevice.gatt.connect();
          log('Connected to GATT Server.');
          uartService = await server.getPrimaryService(UART_SERVICE_UUID);
          log('UART Service obtained.');
          txCharacteristic = await uartService.getCharacteristic(UART_TX_CHARACTERISTIC_UUID);
          log('TX Characteristic obtained.');
          rxCharacteristic = await uartService.getCharacteristic(UART_RX_CHARACTERISTIC_UUID);
          log('RX Characteristic obtained.');
          await rxCharacteristic.startNotifications();
          rxCharacteristic.addEventListener('characteristicvaluechanged', handleRxData);
          log('Notifications started.');

          mtuSize = bleDevice.gatt.mtu || 247; // More realistic default if available
          log(`Assumed/Reported MTU: ${mtuSize} bytes.`);

          isConnected = true;
          connectButton.textContent = 'Disconnect';
          statusDiv.textContent = `Connected to ${bleDevice.name || bleDevice.id}`;
          listDirButton.disabled = false;
          bleDevice.addEventListener('gattserverdisconnected', onDisconnected);
          await listDirectory('/');
        } catch (error) {
          log(`Error connecting: ${error.message}`, true);
          console.error("Connection Error:", error);
          statusDiv.textContent = `Error: ${error.message.substring(0, 50)}...`;
          if (bleDevice && bleDevice.gatt.connected) bleDevice.gatt.disconnect();
        }
      } else {
        if (bleDevice && bleDevice.gatt.connected) {
          log('Disconnecting...');
          bleDevice.gatt.disconnect();
        } else {
          onDisconnected();
        }
      }
    };

    function onDisconnected() {
      log('Device disconnected.');
      isConnected = false;
      connectButton.textContent = 'Connect to Device';
      statusDiv.textContent = 'Disconnected';
      listDirButton.disabled = true;
      rxCharacteristic = null; txCharacteristic = null; uartService = null; bleDevice = null;
      clearFileList();
      fileListDiv.textContent = 'Disconnected. Connect to a device to list files.';
      currentPathInput.value = "/";
    }

    async function sendBleData(data) {
      if (!txCharacteristic || !isConnected) {
        log('Error: TX Characteristic not available or not connected.', true);
        return;
      }
      try {
        // Using writeValueWithoutResponse for speed, as per common UART implementations
        await txCharacteristic.writeValueWithoutResponse(data);
        log(`Sent ${data.byteLength} bytes: ${Array.from(new Uint8Array(data)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
      } catch (error) {
        log(`Error sending data: ${error}`, true);
      }
    }

    // --- Protocol Implementation (LIST_DIR, OPEN_FILE, READ_CHUNK, CLOSE_FILE) ---
    let currentListDirPromise = null;
    let listDirEntries = [];
    let currentOpenFilePromise = null;
    let currentReadChunkPromise = null;
    let currentCloseFilePromise = null;

    async function listDirectory(path) {
      if (!isConnected) { log("Not connected.", true); return; }
      currentPathInput.value = path;
      clearFileList();
      if (path !== "/") { // Add ".." entry for navigation, except for root
        addFileEntry("..", ENTRY_TYPE.DIRECTORY, null, path.substring(0, path.lastIndexOf('/')) || "/");
      }
      log(`Listing directory: ${path}...`);
      listDirButton.disabled = true;
      listDirEntries = [];

      return new Promise(async (resolve, reject) => {
        currentListDirPromise = { resolve, reject, path };
        const pathBytes = new TextEncoder().encode(path);
        // Path Length field itself is 1 byte.
        // If path is "/", Path Length in payload is 1, Path is "/".
        // If path is "/logs", Path Length is 5, Path is "/logs".
        // If path is "", spec says Path Length 0 for root. But our code uses "/".
        // The spec for LIST_DIR CMD Payload: Path Length (1B), Path (ASCII, Variable)
        // "Path Length: Path field's length. If 0, then list root."
        // My previous code had: `payloadLength = 1 + pathBytes.byteLength;` and `view.setUint8(offset, pathBytes.byteLength);`
        // This seems to align with the *spirit* if not the exact wording if path="/" was sent as pathlength=1, path="/".
        // Let's stick to the spec more closely: if path is "/", send pathLength=0.
        let actualPathBytesToSend = pathBytes;
        let pathLengthField = actualPathBytesToSend.byteLength;

        if (path === "/") { // Special handling for root as per spec example (Path Length 0)
          // However, the example LIST_DIR CMD for root has PayloadLen=1, PathLength=1, Path="/".
          // This is contradictory. "Path Length: ... If 0, then list root."
          // vs "Example: CMD ID:01, PayloadLen:1, Payload: PathLength:01, Path:/"
          // Let's try to follow the "Path Length = 0 for root" if the device expects that.
          // For now, I will keep the previous logic which sent "/" with length 1, as it was working.
          // If issues arise, this is a point to check.
          // The example in proto spec shows: Payload: Path Length (1B) = 0x01, Path (ASCII, Var) = `/` (0x2F)
          // This means payload for listing root IS: 0x01 0x2F (PathLength byte itself, then path)
          // So total PayloadLen for LIST_DIR for root is 1 (the PathLength byte) + 1 (the path byte '/'). Total 2.
          // NO, the example shows for LIST_DIR for root: Payload Len (2B) = 1, Payload: Path Length (1B) = 0.
          // This seems to mean the "Path" field is empty, and its length is 0.
          // Let's try the spec: "Path Length: Path field's length. If 0, list root"
          // So, CMD_ID (1B) | Payload Len (2B) | PathActualLength (1B) | Path (Variable)
          // If path == "/", send PathActualLength = 0. Payload will be just this 1 byte.
          // So, command is CMD_ID | 0x0001 (little endian for payload length) | 0x00 (path length is zero)
          // This seems more consistent.

          let pLengthForPayload; // Length of the "Path" string itself.
          let pathBytesForPayload;

          if (path === "/") {
            pLengthForPayload = 0;
            pathBytesForPayload = new Uint8Array(0); // No path bytes
          } else {
            pathBytesForPayload = new TextEncoder().encode(path);
            pLengthForPayload = pathBytesForPayload.byteLength;
          }

          const cmdPayloadLength = 1 + pLengthForPayload; // Path Length (1B) + actual path string
          const buffer = new ArrayBuffer(1 + 2 + cmdPayloadLength); // CMD_ID + OverallPayloadLen_uint16 + (PathLen_uint8 + Path_string)
          const view = new DataView(buffer);

          let offset = 0;
          view.setUint8(offset, CMD_ID.LIST_DIR); offset++;
          view.setUint16(offset, cmdPayloadLength, true); offset += 2; // Overall payload length
          view.setUint8(offset, pLengthForPayload); offset++;       // Length of the path string that follows
          if (pLengthForPayload > 0) {
            new Uint8Array(buffer, offset).set(pathBytesForPayload);
          }

          await sendBleData(buffer);
        }
      }).finally(() => { listDirButton.disabled = false; });
    }
    listDirButton.onclick = () => listDirectory(currentPathInput.value);


    async function openFile(filePath) {
      if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
      log(`Opening file: ${filePath}...`);
      return new Promise(async (resolve, reject) => {
        currentOpenFilePromise = { resolve, reject, filePath };
        const pathBytes = new TextEncoder().encode(filePath);
        const payloadLength = 1 + pathBytes.byteLength; // File Path Length (1B) + File Path string
        const buffer = new ArrayBuffer(1 + 2 + payloadLength);
        const view = new DataView(buffer);
        let offset = 0;
        view.setUint8(offset, CMD_ID.OPEN_FILE); offset++;
        view.setUint16(offset, payloadLength, true); offset += 2;
        view.setUint8(offset, pathBytes.byteLength); offset++;
        new Uint8Array(buffer, offset).set(pathBytes);
        await sendBleData(buffer);
      });
    }

    async function readFileChunk(offset, bytesToRead) {
      if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
      log(`Reading chunk: offset=${offset}, length=${bytesToRead}`);
      return new Promise(async (resolve, reject) => {
        currentReadChunkPromise = { resolve, reject };
        const payloadLength = 4 + 2; // Offset (4B) + Bytes to Read (2B)
        const buffer = new ArrayBuffer(1 + 2 + payloadLength);
        const view = new DataView(buffer);
        let idx = 0;
        view.setUint8(idx, CMD_ID.READ_CHUNK); idx++;
        view.setUint16(idx, payloadLength, true); idx += 2;
        view.setUint32(idx, offset, true); idx += 4;
        view.setUint16(idx, bytesToRead, true);
        await sendBleData(buffer);
      });
    }

    async function closeFile() {
      if (!isConnected) { log("Not connected.", true); return Promise.reject("Not connected"); }
      log(`Closing file...`);
      return new Promise(async (resolve, reject) => {
        currentCloseFilePromise = { resolve, reject };
        const payloadLength = 0;
        const buffer = new ArrayBuffer(1 + 2 + payloadLength);
        const view = new DataView(buffer);
        view.setUint8(0, CMD_ID.CLOSE_FILE);
        view.setUint16(1, payloadLength, true);
        await sendBleData(buffer);
      });
    }

    // --- RX Data Handler ---
    function handleRxData(event) {
      const value = event.target.value; // DataView
      const dataArray = new Uint8Array(value.buffer);
      log(`Received ${dataArray.byteLength} bytes: ${Array.from(dataArray).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);

      if (dataArray.length < 2) { log("Error: RX data too short for Payload Len.", true); return; }
      const payloadLen = value.getUint16(0, true);
      const payload = new DataView(value.buffer, 2, payloadLen);
      log(`Parsed RX Payload Len: ${payloadLen}`);

      if (payload.byteLength !== payloadLen) {
        log(`Error: Actual RX payload length (${payload.byteLength}) does not match header (${payloadLen}).`, true);
      }

      if (currentListDirPromise) {
        // ... (LIST_DIR_RSP handling - ensuring it uses the current path from the promise)
        const promise = currentListDirPromise; // Capture before it's potentially nulled

        if (payloadLen === 0) {
          log("LIST_DIR_RSP: Empty payload or error for path: " + promise.path, true);
          if (promise.reject) promise.reject("Empty LIST_DIR_RSP");
          currentListDirPromise = null; return;
        }
        if (payloadLen === 1 && payload.byteLength >= 1 && payload.getUint8(0) === 0x00) {
          log(`LIST_DIR_RSP for ${promise.path}: No more entries (or empty directory). Listing complete.`);
          if (listDirEntries.length === 0) fileListDiv.innerHTML += `<div>Directory is empty or no entries found.</div>`;
          if (promise.resolve) promise.resolve(listDirEntries);
          currentListDirPromise = null; return;
        }
        if (payload.byteLength < 3) { // Min: More Flag (1) + Entry Type (1) + Name Length (1)
          log(`LIST_DIR_RSP for ${promise.path}: Payload too short (${payload.byteLength}B) for minimal entry.`, true);
          if (promise.reject) promise.reject("LIST_DIR_RSP too short");
          currentListDirPromise = null; return;
        }

        let offset = 0;
        const moreFlag = payload.getUint8(offset); offset++;
        const entryType = payload.getUint8(offset); offset++;
        const nameLength = payload.getUint8(offset); offset++;

        if (offset + nameLength > payload.byteLength) {
          log(`LIST_DIR_RSP for ${promise.path}: Name length (${nameLength}) exceeds payload bounds (${payload.byteLength - offset} available).`, true);
          if (promise.reject) promise.reject("LIST_DIR_RSP name length error");
          currentListDirPromise = null; return;
        }
        const nameBytes = new Uint8Array(payload.buffer, payload.byteOffset + offset, nameLength);
        const name = new TextDecoder().decode(nameBytes);
        offset += nameLength;
        log(`LIST_DIR_RSP: Path=${promise.path}, More=${moreFlag}, Type=${entryType}, Name=${name}`);

        let fileSize = null;
        if (entryType === ENTRY_TYPE.FILE) {
          if (offset + 4 <= payload.byteLength) {
            fileSize = payload.getUint32(offset, true);
            log(`  File Size: ${fileSize}`);
          } else { log(`LIST_DIR_RSP for ${promise.path}: File entry '${name}', but file size is missing or payload too short.`, true); }
        }
        // Construct full path for the entry. promise.path is the *directory* being listed.
        const entryFullPath = (promise.path === '/' ? '/' : promise.path + '/') + name;
        addFileEntry(name, entryType, fileSize, entryFullPath.replace(/\/\//g, '/'));
        listDirEntries.push({ name, type: entryType, size: fileSize, path: entryFullPath.replace(/\/\//g, '/') });

        if (moreFlag === 0x00) {
          log(`LIST_DIR_RSP for ${promise.path}: No more entries. Listing complete.`);
          if (promise.resolve) promise.resolve(listDirEntries);
          currentListDirPromise = null;
        } else {
          log(`LIST_DIR_RSP for ${promise.path}: More entries exist, requesting next...`);
          // Re-send LIST_DIR for the *same directory path* (promise.path)
          const pathForNext = promise.path;
          let pLengthForPayload;
          let pathBytesForPayload;
          if (pathForNext === "/") { pLengthForPayload = 0; pathBytesForPayload = new Uint8Array(0); }
          else { pathBytesForPayload = new TextEncoder().encode(pathForNext); pLengthForPayload = pathBytesForPayload.byteLength; }

          const cmdPayloadLength = 1 + pLengthForPayload;
          const buffer = new ArrayBuffer(1 + 2 + cmdPayloadLength);
          const view = new DataView(buffer);
          let o = 0;
          view.setUint8(o, CMD_ID.LIST_DIR); o++;
          view.setUint16(o, cmdPayloadLength, true); o += 2;
          view.setUint8(o, pLengthForPayload); o++;
          if (pLengthForPayload > 0) new Uint8Array(buffer, o).set(pathBytesForPayload);
          sendBleData(buffer); // The currentListDirPromise remains active for the next response
        }
      } else if (currentOpenFilePromise) {
        const promise = currentOpenFilePromise; currentOpenFilePromise = null;
        if (payloadLen === 4 && payload.byteLength === 4) {
          const fileSize = payload.getUint32(0, true);
          log(`OPEN_FILE_RSP for ${promise.filePath}: Success, File Size = ${fileSize} bytes.`);
          promise.resolve({ filePath: promise.filePath, fileSize });
        } else if (payloadLen === 0) {
          log(`OPEN_FILE_RSP for ${promise.filePath}: Failed to open file.`, true);
          promise.reject(`Failed to open file: ${promise.filePath}`);
        } else {
          log(`OPEN_FILE_RSP for ${promise.filePath}: Unexpected payload length ${payloadLen}.`, true);
          promise.reject(`OPEN_FILE_RSP unexpected payload for ${promise.filePath}`);
        }
      } else if (currentReadChunkPromise) {
        const promise = currentReadChunkPromise; currentReadChunkPromise = null;
        if (payloadLen >= 2 && payload.byteLength >= 2) {
          const actualBytesRead = payload.getUint16(0, true);
          log(`READ_CHUNK_RSP: Actual Bytes Read = ${actualBytesRead}`);
          if (actualBytesRead > 0) {
            if (payload.byteLength >= 2 + actualBytesRead) {
              const fileData = new Uint8Array(payload.buffer, payload.byteOffset + 2, actualBytesRead);
              promise.resolve({ actualBytesRead, data: fileData });
            } else {
              log("READ_CHUNK_RSP: actualBytesRead > 0 but payload too short for data.", true);
              promise.reject("READ_CHUNK_RSP: inconsistent payload for data");
            }
          } else {
            promise.resolve({ actualBytesRead: 0, data: new Uint8Array(0) });
          }
        } else {
          log("READ_CHUNK_RSP: Payload too short for 'Actual Bytes Read'.", true);
          promise.reject("READ_CHUNK_RSP: payload too short");
        }
      } else if (currentCloseFilePromise) {
        const promise = currentCloseFilePromise; currentCloseFilePromise = null;
        if (payloadLen === 0) {
          log("CLOSE_FILE_RSP: File closed successfully.");
          promise.resolve();
        } else {
          log(`CLOSE_FILE_RSP: Unexpected payload length ${payloadLen}. Assuming closed.`, true);
          promise.resolve();
        }
      } else {
        log("Received data, but no matching command promise was found. Ignoring.", true);
      }
    }

    // --- File Download Logic ---
    async function downloadFileCore(filePath, fileName, expectedSize) {
      // This function will handle the BLE communication to get the raw ArrayBuffer
      if (!isConnected) {
        log("Cannot download: Not connected.", true);
        throw new Error("Not connected");
      }
      log(`Starting raw download for: ${filePath} (Size: ${expectedSize} bytes)`);
      listDirButton.disabled = true;

      try {
        const { fileSize: openedFileSize } = await openFile(filePath);
        let effectiveFileSize = openedFileSize;
        if (expectedSize !== null && openedFileSize !== expectedSize) {
          log(`Warning: Opened file size (${openedFileSize}) differs from listed size (${expectedSize}). Using opened size.`);
        } else if (expectedSize !== null) {
          effectiveFileSize = expectedSize; // Prefer listed size if consistent or only one available
        }
        log(`File opened: ${filePath}, Effective Size: ${effectiveFileSize} bytes.`);

        let receivedBytes = 0;
        const fileChunks = [];
        // Max data in READ_CHUNK_RSP payload = MTU - ATT_HDR(3) - UART_RX_HDR(0 for this level) - Proto_RSP_HDR(PayloadLen=2 + ActualBytesRead=2)
        // So, max data = MTU - 3 - 4 = MTU - 7.
        // Let's be slightly more conservative: mtuSize - 10 or a fixed like 128.
        const CHUNK_SIZE_TO_REQUEST = Math.max(16, Math.min(128, mtuSize - 10));
        log(`Requesting chunks of size: ${CHUNK_SIZE_TO_REQUEST}`);

        while (receivedBytes < effectiveFileSize) {
          const bytesToRead = Math.min(CHUNK_SIZE_TO_REQUEST, effectiveFileSize - receivedBytes);
          if (bytesToRead <= 0) break;

          statusDiv.textContent = `Downloading ${fileName}: ${Math.round((receivedBytes / effectiveFileSize) * 100)}%`;
          const { actualBytesRead, data } = await readFileChunk(receivedBytes, bytesToRead);

          if (actualBytesRead > 0 && data) {
            fileChunks.push(data);
            receivedBytes += actualBytesRead;
            log(`Downloaded ${receivedBytes} / ${effectiveFileSize} bytes...`);
          } else {
            log("Reached EOF or read error (actualBytesRead is 0 or no data).");
            if (receivedBytes < effectiveFileSize) {
              log(`Warning: Download ended prematurely. Expected ${effectiveFileSize}, got ${receivedBytes}.`, true);
            }
            break;
          }
        }
        statusDiv.textContent = `Downloaded ${fileName}: ${Math.round((receivedBytes / effectiveFileSize) * 100)}% Complete.`;

        if (fileChunks.length > 0) {
          const totalReceived = fileChunks.reduce((acc, chunk) => acc + chunk.byteLength, 0);
          if (totalReceived !== receivedBytes) { // Sanity check
            log(`Internal Mismatch: receivedBytes=${receivedBytes}, chunksTotal=${totalReceived}`, true);
          }
          // Combine chunks into a single ArrayBuffer
          const finalBuffer = new Uint8Array(totalReceived);
          let currentOffset = 0;
          for (const chunk of fileChunks) {
            finalBuffer.set(new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength), currentOffset);
            currentOffset += chunk.byteLength;
          }
          return finalBuffer.buffer; // Return the ArrayBuffer
        } else if (effectiveFileSize === 0 && receivedBytes === 0) {
          log("Downloaded an empty file successfully.");
          return new ArrayBuffer(0);
        }
        else {
          throw new Error(`Download failed or file empty. Received ${receivedBytes} of ${effectiveFileSize} bytes.`);
        }

      } catch (error) {
        log(`Error during raw download of ${filePath}: ${error}`, true);
        statusDiv.textContent = `Error downloading ${filePath}`;
        throw error; // Re-throw to be caught by caller
      } finally {
        try {
          await closeFile();
          log("File closed after raw download attempt for " + filePath);
        } catch (closeError) {
          log(`Error closing file after raw download of ${filePath}: ${closeError}`, true);
        }
        listDirButton.disabled = false;
        if (isConnected) statusDiv.textContent = `Connected to ${bleDevice.name || bleDevice.id}`;
      }
    }

    async function downloadFile(filePath, fileName, expectedSize) {
      try {
        const rawFileBuffer = await downloadFileCore(filePath, fileName, expectedSize);
        if (rawFileBuffer) {
          const fileBlob = new Blob([rawFileBuffer]);
          const downloadUrl = URL.createObjectURL(fileBlob);
          const a = document.createElement('a');
          a.href = downloadUrl;
          a.download = fileName;
          document.body.appendChild(a);
          a.click();
          URL.revokeObjectURL(downloadUrl);
          a.remove();
          log(`Raw file "${fileName}" saved.`);
          statusDiv.textContent = `Saved ${fileName}`;
        }
      } catch (error) {
        log(`Overall download process for ${fileName} failed: ${error}`, true);
      }
    }

    async function visualizeGpsData(rawTrackData) {
      function processTrackData(rawData) {
        if (!rawData || rawData.length === 0) {
          return {
            points: [],
            fullTrackGeoJSON: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
          };
        }

        const points = rawData.map(p => ({
          longitude: p.longitude_scaled_1e5 / 1e5,
          latitude: p.latitude_scaled_1e5 / 1e5,
          altitude: p.altitude_m_scaled_1e1 / 1e1,
          timestamp: p.timestamp // Unix timestamp in seconds
        })).sort((a, b) => a.timestamp - b.timestamp); // 确保按时间排序

        const coordinates = points.map(p => [p.longitude, p.latitude, p.altitude]);

        return {
          points: points, // 包含转换后经纬高和时间戳的数组
          fullTrackGeoJSON: {
            type: 'Feature',
            geometry: {
              type: 'LineString',
              coordinates: coordinates
            },
            properties: {}
          }
        };
      }

      const { points, fullTrackGeoJSON } = processTrackData(rawTrackData);

      const slider = document.getElementById('timeslider');
      const timestampDisplay = document.getElementById('timestamp-display');

      // 3. 初始化 MapLibre GL JS 地图
      const map = new maplibregl.Map({
        container: 'map',
        style: 'https://tiles.openfreemap.org/styles/liberty', // 您指定的瓦片服务
        center: points.length > 0 ? [points[0].longitude, points[0].latitude] : [139.767, 35.681], // 初始中心点 (东京站)
        zoom: 14
      });

      map.on('load', () => {
        if (points.length === 0) {
          console.warn("没有轨迹数据可加载。");
          timestampDisplay.textContent = "无轨迹数据";
          slider.disabled = true;
          return;
        }

        // 4. 添加轨迹线数据源和图层
        map.addSource('full-track', {
          type: 'geojson',
          data: fullTrackGeoJSON
        });

        map.addLayer({
          id: 'full-track-line',
          type: 'line',
          source: 'full-track',
          layout: {
            'line-join': 'round',
            'line-cap': 'round'
          },
          paint: {
            'line-color': '#007bff', // 轨迹线颜色 (蓝色)
            'line-width': 5,
            'line-opacity': 0.8
          }
        });

        // 5. 添加已行进轨迹的数据源和图层
        map.addSource('travelled-track', {
          type: 'geojson',
          data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
        });

        map.addLayer({
          id: 'travelled-track-line',
          type: 'line',
          source: 'travelled-track',
          layout: {
            'line-join': 'round',
            'line-cap': 'round'
          },
          paint: {
            'line-color': '#28a745', // 已行进轨迹颜色 (绿色)
            'line-width': 6, // 比完整轨迹稍宽一点以覆盖
            'line-opacity': 0.9
          }
        }); // 确保在完整轨迹线上方，但可以调整

        // 6. 添加当前位置标记的数据源和图层
        map.addSource('current-point', {
          type: 'geojson',
          data: {
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [points[0].longitude, points[0].latitude]
            },
            properties: {}
          }
        });

        map.addLayer({
          id: 'current-point-marker',
          type: 'circle',
          source: 'current-point',
          paint: {
            'circle-radius': 8,
            'circle-color': '#dc3545', // 标记颜色 (红色)
            'circle-stroke-width': 2,
            'circle-stroke-color': '#ffffff'
          }
        });

        // 7. 设置并监听进度条
        slider.max = points.length - 1;
        updateMapForIndex(0); // 初始化显示第一个点

        slider.addEventListener('input', (e) => {
          const index = parseInt(e.target.value);
          updateMapForIndex(index);
        });

        // 8. 更新地图的函数
        function updateMapForIndex(index) {
          if (index < 0 || index >= points.length) return;

          const currentPointData = points[index];

          // 更新当前位置标记
          map.getSource('current-point').setData({
            type: 'Feature',
            geometry: {
              type: 'Point',
              coordinates: [currentPointData.longitude, currentPointData.latitude]
            },
            properties: { // 可以添加一些属性用于调试或显示
              timestamp: currentPointData.timestamp,
              altitude: currentPointData.altitude
            }
          });

          // 更新已行进的轨迹
          const travelledCoordinates = points.slice(0, index + 1).map(p => [p.longitude, p.latitude, p.altitude]);
          map.getSource('travelled-track').setData({
            type: 'Feature',
            geometry: {
              type: 'LineString',
              coordinates: travelledCoordinates
            },
            properties: {}
          });

          // 更新时间戳显示
          const date = new Date(currentPointData.timestamp * 1000); // JS Date需要毫秒
          timestampDisplay.textContent = date.toLocaleString() + ` (Alt: ${currentPointData.altitude.toFixed(1)}m)`;

          // (可选) 将地图视图平移到当前点
          map.panTo([currentPointData.longitude, currentPointData.latitude]);
        }

        // 调整地图边界以适应整个轨迹
        if (fullTrackGeoJSON.geometry.coordinates.length > 1) {
          const bounds = new maplibregl.LngLatBounds();
          fullTrackGeoJSON.geometry.coordinates.forEach(coord => {
            bounds.extend(coord.slice(0, 2)); // LngLatBounds只需要经纬度
          });
          map.fitBounds(bounds, {
            padding: 50 // 在边界周围留一些空间
          });
        }
      });

      map.on('error', (e) => {
        console.error('MapLibre GL JS Error:', e);
        if (e.error && e.error.status === 403 && e.url && e.url.includes('openfreemap.org')) {
          alert("无法加载 OpenFreeMap 瓦片。请检查网络连接或瓦片服务状态。有时瓦片服务可能会有速率限制或临时不可用。");
        } else if (e.error) {
          alert(`加载地图时出错: ${e.error.message || '未知错误'}`);
        }
      });

    }


    async function downloadAndConvertToGpx(filePath, fileName, expectedSize, download) {
      try {
        statusDiv.textContent = `Downloading ${fileName} for GPX conversion...`;
        const rawFileBuffer = await downloadFileCore(filePath, fileName, expectedSize);

        if (!rawFileBuffer) {
          log(`GPX Conversion: Failed to download raw data for ${fileName}.`, true);
          statusDiv.textContent = `GPX conversion failed for ${fileName}.`;
          return;
        }
        log(`GPX Conversion: Raw data downloaded for ${fileName} (${rawFileBuffer.byteLength} bytes). Decoding...`);
        statusDiv.textContent = `Decoding ${fileName}...`;

        const decodedPoints = gpsDecoder.decode(rawFileBuffer);
        if (!decodedPoints || decodedPoints.length === 0) {
          log(`GPX Conversion: No points decoded from ${fileName}, or decoder returned empty.`, true);
          alert(`Could not decode any GPX points from ${fileName}. Check logs for details.`);
          statusDiv.textContent = `GPX decoding failed for ${fileName}.`;
          return;
        }

        log(`GPX Conversion: Decoded ${decodedPoints.length} points. Generating GPX string...`);
        statusDiv.textContent = `Generating GPX for ${fileName}...`;

        const gpxString = pointsToGpxString(decodedPoints, fileName);
        await visualizeGpsData(decodedPoints);
        if (!gpxString) {
          log(`GPX Conversion: Failed to generate GPX string for ${fileName}.`, true);
          alert(`Could not generate GPX string from decoded points for ${fileName}.`);
          statusDiv.textContent = `GPX generation failed for ${fileName}.`;
          return;
        }

        const gpxFileName = fileName.replace(/\.[^/.]+$/, "") + ".gpx";
        const gpxBlob = new Blob([gpxString], { type: 'application/gpx+xml' });
        const downloadUrl = URL.createObjectURL(gpxBlob);
        if (download) {
          const a = document.createElement('a');
          a.href = downloadUrl;
          a.download = gpxFileName;
          document.body.appendChild(a);
          a.click();
          URL.revokeObjectURL(downloadUrl);
          a.remove();
          log(`File "${gpxFileName}" saved.`);
          statusDiv.textContent = `Saved ${gpxFileName}`;
        }

      } catch (error) {
        log(`Overall GPX conversion process for ${fileName} failed: ${error}`, true);
        alert(`Error during GPX conversion for ${fileName}: ${error.message}`);
        statusDiv.textContent = `GPX conversion error for ${fileName}`;
      }
    }


    // --- Navigation ---
    function navigateToDirectory(currentFullPath, dirNameClicked) {
      let newPath;
      if (dirNameClicked === "..") {
        if (currentFullPath === "/" || !currentFullPath.includes('/')) {
          newPath = "/";
        } else {
          // currentFullPath is path of ".." entry, which is the parent dir.
          // So if currentFullPath = /foo/bar (meaning .. is in /foo/bar, pointing to /foo)
          // then newPath should be /foo.
          // The `path` passed to addFileEntry for ".." is already the parent path.
          newPath = currentFullPath; // The path for ".." is its destination
        }
      } else {
        // dirNameClicked is a directory name, currentFullPath is its path.
        newPath = currentFullPath;
      }
      newPath = newPath.replace(/\/\//g, '/'); // Sanitize
      if (newPath !== "/" && newPath.endsWith("/")) newPath = newPath.slice(0, -1); // Remove trailing slash unless root
      if (newPath === "") newPath = "/";


      currentPathInput.value = newPath;
      listDirectory(newPath);
    }

    // Initial setup
    log("Page loaded. Ready to connect.");
    if (!navigator.bluetooth) {
      log("Web Bluetooth API is not available in this browser. Please use compatible browser (e.g., Chrome, Edge).", true);
      connectButton.disabled = true;
      statusDiv.textContent = "Web Bluetooth not supported.";
    }

  </script>
</body>

</html>
